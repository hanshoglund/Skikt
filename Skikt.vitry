; load "~/Documents/Musik/Skikt/Skikt.vitry"

; =============================================================================
; Skikt
; Hans Hoglund (2011)
; Vitry v0.1.2
; =============================================================================

module Hans.Music.Skikt

scoreEditor = "/Applications/Sibelius 6.app"
fileDir     = "/Users/hans/Documents/Musik/Skikt/output/"
fileName    = "out"
preview     = false
fixClefs    = false
verbose     = `output

; =============================================================================
; FOMUS

; module Music.Fomus

; Interface to the FOMUS notation engine by David Psenicka
; See http://fomus.sourceforge.net/

; The workflow is to create a data structure representing a score
; and pass it to the fomus function. This function generates a
; text on a format understood by Fomus, which may be written to
; a fomus text file.

time     = nil | prec | "+"
grace    = nil | prec | "+"
dur      = nil | prec | "+" | "-"
pitch    = nil | prec
dyn      = nil | double
voice    = nil | int  | [int]
fomusId  = str

markType = "(.." | "*" | "+" | "-" | "." | ".((." | ".(." | "..)" | "..))" | "..<"
         | "..>" | "." | "..dash)" | "..dash))" | "..dot)" | "..dot))" | "..grace)"
         | "..ped" | "..tup" | "..x!" | "..x^" | "..x_" | ".<." | ".>." | ".dash((."
         | ".dash(." | ".dot((." | ".dot(." | ".grace(." | ".ped." | ".x!." | ".x^."
         | ".x_." | "/" | "/." | "0" | "<.." | ">" | ">.." | "^" | "arco" | "arp"
         | "arp^" | "arp_" | "artharm-base" | "artharm-sounding" | "artharm-touched"
         | "bellsup" | "break<" | "break>" | "breath" | "breath<" | "breath>"
         | "cuivre" | "damp" | "dash((.." | "dash(.." | "dot((.." | "dot(.."
         | "downbow" | "dyn" | "etouf" | "f" | "ferm" | "ferm-long" | "ferm-short"
         | "ferm-verylong" | "ff" | "fff" | "ffff" | "fffz" | "ffz" | "flaut" | "flt"
         | "fz" | "gliss<" | "gliss>" | "grace(.." | "leg" | "legno" | "longtr"
         | "longtr2" | "lv" | "mf" | "moltoleg" | "moltovib" | "mp" | "mute"
         | "natharm-sounding" | "natharm-string" | "natharm-touched" | "nonleg"
         | "nonvib" | "o" | "ord" | "p" | "ped.." | "pizz" | "pont" | "port<"
         | "port>" | "pp" | "ppp" | "pppp" | "ppppp" | "pppppp" | "punta" | "rf"
         | "rfz" | "ric" | "salt" | "sf" | "sff" | "sfff" | "sfffz" | "sffz" | "sfz"
         | "slap" | "snap" | "snappizz" | "spic" | "sul" | "table" | "tall" | "tasto"
         | "tempo" | "trem" | "trem2" | "tup.." | "unmute" | "upbow" | "vib" | "x"
         | "x!" | "x!.." | "x^" | "x^.." | "x_" | "x_.." | "~" | (`-) | (`.) | (`!) | (`+)

mark     = markType
         | (markType, (num | str))
         | (markType, (num | str), (num | str))

setting  = (str, (str | num | [str] | [num]))

clef     = [setting]
staff    = ([clef],  [setting])
template = fomusId
percInst = fomusId
         | (fomusId, [setting])
inst     = fomusId
         | (fomusId, template, [percInst], [staff], [setting])
         | (fomusId, template, [percInst])
partMap  = (voice, voice, fomusId)
metaPart = (fomusId, [partMap])
part     = nil
         | metaPart
         | (fomusId, inst, [setting])
note     = (part, voice, time, grace, dur, pitch, dyn, [mark], [setting])
         | (part, voice, time, dur, pitch, dyn, [mark], [setting])
         | (time, dur, pitch, dyn, [mark], [setting])
         | (dur, pitch, dyn, [mark], [setting])
         | (pitch, dyn, [mark], [setting])
rest     = (part, voice, time, grace, dur, [mark], [setting])
         | (time, dur, [mark], [setting])
meas     = (time, dur, [setting])
         | (dur, [setting])

decl     = part | inst | metaPart | percInst | staff | clef
event    = note | rest | meas

music    = [event]
         | (`par, _, _)
         | (`seq, _, _)

score    = (music, [decl], [setting])


expandEvent e : event = match e
    (r, v, t, g, d, p, n, m, s)  : note = e
    (r, v, t, d, p, n:dyn, m, s) : note = (r,  v,  t,  (), d,  p, n, m, s)
    (t, d, p, n:dyn, m, s)       : note = ((), (), t,  (), d,  p, n, m, s)
    (d, p, n:dyn, m, s)          : note = ((), (), (), (), d,  p, n, m, s)
    (p, n:dyn, m, s)             : note = ((), (), (), (), (), p, n, m, s)
    (p, v, t, g, d, m, s)        : rest = e
    (t, d, m, s)                 : rest = ((), (), t,  (), d,  m, s)
    (t, d, s)                    : meas = e
    (d, s)                       : meas = ((), d, s)

getNotePart    (r, _, _, _, _, _, _, _, _) = r
getNoteVoice   (_, v, _, _, _, _, _, _, _) = v
getNoteTime    (_, _, t, _, _, _, _, _, _) = t
getNoteGrace   (_, _, _, g, _, _, _, _, _) = g
getNoteDur     (_, _, _, _, d, _, _, _, _) = d
getNotePitch   (_, _, _, _, _, p, _, _, _) = p
getNoteDyn     (_, _, _, _, _, _, n, _, _) = n
getNoteMarks   (_, _, _, _, _, _, _, m, _) = m
getRestPart    (r, _, _, _, _, _, _)       = r
getRestVoice   (_, v, _, _, _, _, _)       = v
getRestTime    (_, _, t, _, _, _, _)       = t
getRestGrace   (_, _, _, g, _, _, _)       = g
getRestDur     (_, _, _, _, d, _, _)       = d
getRestMarks   (_, _, _, _, _, m, _)       = m
getMeasTime    (t, _, _)                   = t
getMeasDur     (_, d, _)                   = d
setNotePart  r (_, v, t, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteVoice v (r, _, t, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteTime  t (r, v, _, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteGrace g (r, v, t, _, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteDur   d (r, v, t, g, _, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNotePitch p (r, v, t, g, d, _, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteDyn   n (r, v, t, g, d, p, _, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteMarks m (r, v, t, g, d, p, n, _, s) = (r, v, t, g, d, p, n, m, s)
setRestPart  r (_, v, t, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestVoice v (r, _, t, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestTime  t (r, v, _, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestGrace g (r, v, t, _, d, m, s)       = (r, v, t, g, d, m, s)
setRestDur   d (r, v, t, g, _, m, s)       = (r, v, t, g, d, m, s)
setRestMarks m (r, v, t, g, d, _, s)       = (r, v, t, g, d, m, s)
setMeasTime  t (_, d, s)                   = (t, d, s)
setMeasDur   d (t, _, s)                   = (t, d, s)

; event -> dur
getTime e = match e
    e : note = (getNoteTime . expandEvent) e
    e : rest = (getRestTime . expandEvent) e
    e : meas = (getMeasTime . expandEvent) e
getDur e = match e
    e : note = (getNoteDur . expandEvent) e
    e : rest = (getRestDur . expandEvent) e
    e : meas = (getMeasDur . expandEvent) e
getPart e = match e
    e : note = (getNotePart . expandEvent) e
    e : rest = (getRestPart . expandEvent) e
getVoice e = match e
    e : note = (getNoteVoice . expandEvent) e
    e : rest = (getRestVoice . expandEvent) e
getGrace e = match e
    e : note = (getNoteGrace . expandEvent) e
    e : rest = (getRestGrace . expandEvent) e
getMarks e = match e
    e : note = (getNoteMarks . expandEvent) e
    e : rest = (getRestMarks . expandEvent) e

; event -> prec |Â "+"
getActualDur x = if (getTime x == ()) then 0 else (getDur x)

; note -> pitch
getPitch = getNotePitch . expandEvent
getDyn   = getNoteDyn   . expandEvent

; part | metaPart -> id
getName x = match x
    (id, _, _) : part  = id
    (id, _)    : metaPart = id

; a -> event -> event
setTime   x e = match e
    e : note = setNoteTime  x (expandEvent e)
    e : rest = setRestTime  x (expandEvent e)
    e : meas = setMeasTime  x (expandEvent e)
setDur    x e = match e
    e : note = setNoteDur   x (expandEvent e)
    e : rest = setRestDur   x (expandEvent e)
    e : meas = setMeasDur   x (expandEvent e)
setPart   x e = match e
    e : note = setNotePart  x (expandEvent e)
    e : rest = setRestPart  x (expandEvent e)
setVoice  x e = match e
    e : note = setNoteVoice x (expandEvent e)
    e : rest = setRestVoice x (expandEvent e)
setGrace  x e = match e
    e : note = setNoteGrace x (expandEvent e)
    e : rest = setRestGrace x (expandEvent e)
setMarks  x e = match e
    e : note = setNoteMarks x (expandEvent e)
    e : rest = setRestMarks x (expandEvent e)
setPitch  x e = setNotePitch x (expandEvent e)
setDyn    x e = setNoteDyn   x (expandEvent e)

withTime  f x = setTime  (f (getTime  x)) x
withDur   f x = setDur   (f (getDur   x)) x
withPart  f x = setPart  (f (getPart  x)) x
withVoice f x = setVoice (f (getVoice x)) x
withGrace f x = setGrace (f (getGrace x)) x
withMarks f x = setMarks (f (getMarks x)) x
withPitch f x = setPitch (f (getPitch x)) x
withDyn   f x = setDyn   (f (getDyn   x)) x


; Time and duration is context-sensitive in Fomus. This means that we
; can get unexpected results when assembling events from various sources.

; To counter the problem we introduce normal-form event lists which are
; unaffected by surrounding events
;
; Normal form events lists take three shapes:
;   - Relative, where
;       - durations are given explitly
;       - the first time value is a number
;       - all other time values are "+" or nil
;   - Absolute, where
;       - time values are given explitly
;       - the last duration is a number
;       - and all other durations are "+" or nil
;   - Explicit, where
;       - all time values and durations are given explitly

assureTimeAndDur t nt d nd event =
    match (getTime event, getDur event)
        (_ : nt, _     ) = false
        (_,      _ : nd) = false
        (_ : t,  _ : d ) = true
        _                = false

; event -> bool
isRelativeEvent = assureTimeAndDur ("+" | ()) {}         _          ("+" | ())
isAbsoluteEvent = assureTimeAndDur _          ("+" | ()) ("+" | ()) {}
isExplicitEvent = assureTimeAndDur _          ("+" | ()) _          ("+" | ())

; [event] -> bool
isRelative xs = match xs
    _ : [] = true
    xs     = isExplicitEvent (head xs) && (all isRelativeEvent) (tail xs)
isAbsolute xs = match xs
    _ : [] = true
    xs     = isExplicitEvent (last xs) && (all isAbsoluteEvent) (init xs)
isExplicit = all isExplicitEvent

isInNormalForm xs = isRelative xs || isAbsolute xs || isExplicit xs


; Basic event lists builders

; [time] -> [dur] -> [pitch] -> [note]
notes times durs pitches = zip6 times durs pitches (loop 0.5) (loop []) (loop [])

; [time] -> [dur] -> [note]
rests times durs         = zip4 times durs (loop []) (loop [])



; The following functions generates music in relative form

; [dur] -> [pitch] -> [note]
melody durs pitches = match (durs, pitches)
    _ : [], _        = []
    _,      _ : []   = []
    (d, ds), (p, ps) = prepend (0, d, p, 0.5, [], []) (delay notes (loop "+") ds ps)

chordT time dur pitches = match pitches
    _ : []  = []
    (p, ps) = prepend (time, dur, p, 0.5, [], []) (delay notes (loop nil) (loop dur) ps)
chordsT time1 time2 durs pitches = match (durs, pitches)
    _ : [], _        = []
    _,      _ : []   = []
    (d, ds), (p, ps) = (delay chordT time1 d p ++ chordsT time2 time2 ds ps)

; dur -> [pitch] -> [note]
chord = chordT 0

; [dur] -> [[pitch]] -> [note]
chords = chordsT 0 "+"

; [mark] -> [mark] -> [mark] -> [note] -> [note]
phraseNotes attack sustain release notes =
    [setMarks attack (head notes)]
    ++ map (setMarks sustain) ((init . tail) notes)
    ++ [setMarks release (last notes)]

; [mark] -> [mark] -> [mark] -> [dur] -> [pitch]
phrase attack sustain release       = phraseNotes attack sustain release .' melody
; [mark] -> [mark] -> [mark] -> [dur] -> [[pitch]]
chordsPhrase attack sustain release = phraseNotes attack sustain release .' chords
; [mark] -> dur -> [pitch]
chordPhrase marks                   = phraseNotes marks marks marks .' chord

legato               = phrase ["(.."] [".(."] ["..)"]
dashedLegato         = phrase ["dash(.."] [".dash(."] ["..dash)"]
dottedLegato         = phrase ["dot(.."] [".dot(."] ["..dot)"]
staccato             = phrase ["."] ["."] ["."]
tenuto               = phrase ["-"] ["-"] ["-"]
portato              = phrase ["(..", "."] [".(.", "."] ["..)", "."]
moltoPortato         = phrase ["-", "."] ["-", "."] ["-", "."]
chordsLegato         = chordsPhrase ["(.."] [] ["..)"]
chordsDashedLegato   = chordsPhrase ["dash(.."] [] ["..dash)"]
chordsDottedLegato   = chordsPhrase ["dot(.."] [] ["..dot)"]
chordsStaccato       = chordsPhrase ["."] ["."] ["."]
chordsTenuto         = chordsPhrase ["-"] ["-"] ["-"]
chordsPortato        = chordsPhrase ["(..", "."] ["."] ["..)", "."]
chordsMoltoPortato   = chordsPhrase ["-", "."] ["-", "."] ["-", "."]
chordArp             = chordsPhrase ["arp"]
chordArpUp           = chordsPhrase ["arp^"]
chordArpDown         = chordsPhrase ["arp_"]
chordsArp            = chordsPhrase ["arp"] ["arp"] ["arp"]
chordsArpUp          = chordsPhrase ["arp^"] ["arp^"] ["arp^"]
chordsArpDown        = chordsPhrase ["arp_"] ["arp_"] ["arp_"]


; [dur] -> [dur] -> [pitch] -> [event]
restMelody durs restDurs pitches =
    interl (melody durs pitches) (rests (loop "+") restDurs)

; [dur] -> [dur] -> [[pitch]] -> [note]
restChords durs restDurs pitches =
    interl (chords durs pitches) (rests (loop "+") restDurs)

; [mark] -> [mark] -> [mark] -> [dur] -> [dur] -> [pitch] -> [event]
restPhrase attack sustain release durs restDurs pitches =
    interl (phrase attack sustain release durs pitches) (rests (loop "+") restDurs)

; FIXME
; [mark] -> [mark] -> [mark] -> [dur] -> [dur] -> [[pitch]]
; restChordsPhrase attack sustain release durs restDurs pitches  =
    ; interl (chordsPhrase attack sustain release durs pitches) (rests (loop "+") restDurs)



; The music type allow us to sequence events in an abstract fashion

; music -> music -> music
sequence a b = (`seq, a, b)
parallel a b = (`par, a, b)

; time -> [event] -> [event]
offsetMusic time = map (withTime (fn (x) match x (x : prec = x + time) (_ = x)))

; music -> dur
duration m = match m
    (_ : `seq, a, b) = (+) (duration a) (duration b)
    (_ : `par, a, b) = max (duration a) (duration b)
    m : [event]      = (getTime . head) m + (sum . map getActualDur) m

; music -> [event]
musicToEvents m = match m
    (_ : `seq, a, b) = musicToEvents a ++ offsetMusic (duration a) (musicToEvents b)
    (_ : `par, a, b) = musicToEvents a ++ musicToEvents b
    m : [event]      = m

mapMusic f m = match m
    (_ : `seq, a, b) = (`seq, mapMusic f a, mapMusic f b)
    (_ : `par, a, b) = (`par, mapMusic f a, mapMusic f b)
    m : [event]      = map f m



; Simple inspectors for the repl

declType d = match d
    d : part     = `part
    d : inst     = `inst
    d : percInst = `percInst
    d : staff    = `staff
    d : clef     = `clef

eventType e = match e
    e : note     = `note
    e : rest     = `rest
    e : meas     = `meas


; Main export function
; Converts the given data structure to a text format understood by Fomus.
;    ( mark  |  decl  |  event  | setting | [mark] | [decl] | [event] | [setting] | score ) -> str

fomus data = match data
    (id, x, y)                : mark = "[" ++ string id ++ " " ++ fomus x ++ " " ++ fomus y ++ "]"
    (id, x)                   : mark = "[" ++ string id ++ " " ++ fomus x ++ "]"
    id                        : mark = "[" ++ string id ++ "]"

    (name, value)             : setting = name ++ "=" ++ fomus value

    (id, template, percInsts) : inst = "inst <"
                                    ++ "id="        ++ id              ++ " "
                                    ++ "template="  ++ fomus template  ++ " "
                                    ++ "percinsts=" ++ fomusList percInsts ++ ">"
    (id, inst, settings)      : part = "part <"
                                    ++ "id="   ++ id         ++ " "
                                    ++ "inst=" ++ fomus inst ++ " "
                                    ++ fomus settings        ++ ">"
    (id, partMaps)            : metaPart = "metapart <"
                                    ++ "id="    ++ string id          ++ " "
                                    ++ "parts=" ++ fomusList partMaps ++ ">"
    (from, to, id)            : partMap = "<"
                                    ++ "from-voice=" ++ string from ++ " "
                                    ++ "to-voice="   ++ string to   ++ " "
                                    ++ "part="       ++  string id  ++ ">"

    (part, voice, time, grace, dur, pitch, dyn, marks, settings) : note = "note "
                                    ++ maybePart part   ++ " "
                                    ++ maybeVoice voice ++ " "
                                    ++ maybeTime time   ++ " "
                                    ++ maybeGrace grace ++ " "
                                    ++ maybeDur dur     ++ " "
                                    ++ maybePitch pitch ++ " "
                                    ++ maybeDynamic dyn ++ " "
                                    ++ fomus marks      ++ " "
                                    ++ fomus settings   ++ ";"
    (part, voice, time, grace, dur, marks, settings) : rest = "rest "
                                    ++ maybePart part   ++ " "
                                    ++ maybeVoice voice ++ " "
                                    ++ maybeTime time   ++ " "
                                    ++ maybeGrace grace ++ " "
                                    ++ maybeDur dur     ++ " "
                                    ++ fomus marks      ++ " "
                                    ++ fomus settings   ++ ";"
    (time, dur, settings)     : meas = ""
                                    ++ maybeTime time   ++ " "
                                    ++ maybeDur  dur    ++ " "
                                    ++ "meas <" ++ fomus settings ++ ">"
    event                     : event = (fomus . expandEvent) event

    (events, decls, settings) : score = join "\n\n" [fomus settings, fomus decls, fomus events]

    settings : [setting]    = join " " (map fomus settings)
    marks    : [mark]       = join " " (map fomus marks)
    event    : [event]      = join "\n" (map fomus event)
    decls    : [decl]       = join "\n" (map fomus decls)
    music    : music        = (fomus . musicToEvents) music
    x        : str          = fomusStr x
    x        : num          = string x
    x        : ()           = ""
    xs       : [_]          = fomusList xs


fomusList xs = "(" ++ join " " (map fomus xs) ++ ")"
fomusStr x   = "\"" ++ x ++ "\""

maybePart x    = match x (x : () = "") (x = "part="    ++ getName x)
maybeVoice x   = match x (x : () = "") (x = "voice="   ++ listOrString x)
maybeTime x    = match x (x : () = "") (x = "time="    ++ string x)
maybeGrace x   = match x (x : () = "") (x = "grace="   ++ string x)
maybeDur x     = match x (x : () = "") (x = "dur="     ++ string x)
maybePitch x   = match x (x : () = "") (x = "pitch="   ++ string x)
maybeDynamic x = match x (x : () = "") (x = "dynamic=" ++ string x)
listOrString x = match x (x : [_] = fomusList x) (_ = string x)




; =============================================================================
; Util

; Misc

fst (a, b)  = a
snd (a, b)  = b

loopTimes n = take n . loop

major root  = [root, root + 4, root + 7]


; Ranges

range a = (a, a)

; range -> range | ()
overlap (a, b) (c, d) =
    if  (a > b || c > d) then nil else
        let x = max a c
            y = min b d
            if  (x > y) then nil else (x, y)

; a -> range a -> bool
isInRange (a, b) x = a <= x && x <= b
isOverlapping = (!= ()) .' overlap

; range prec -> prec
randomRange (rangeLow, rangeHigh) = random (succ rangeHigh - rangeLow) + rangeLow


; Curves

noise  = unfold (fn (x) (randomDouble () * 2.0 - 1.0, 0)) 0
line n = cycle (map (approx . flip (/) n) (0 .. n))
sinG   = map (sin . (* 2.0 * pi))
cosG   = map (cos . (* 2.0 * pi))
addG   = zipWith (+)
mulG   = zipWith (*)


; Returns a list of length n approximating the values of the given
; list by partitioning it and calculating the mean of each sublist.
; Returns the original list if its length is >= n
;   int -> [prec] -> [prec] | [real] -> [real]
sample n = map mean . partitionInto n

;   int -> [prec] -> [prec] | [real] -> [real]
; interpolate n =

sigToPos = map (fn (x) (x + 1.0) / 2.0)
posToSig = map (fn (x) x * 2.0 - 1.0)


; Plotting

plotWindowSize    = (700, 200)
plotWindowPadding = (0, 23)

; Displays a simple plot of the given list of numbers in a window
; Precise numbers may be of any magnitude
; Real numbers are assumed to be in the range -1.0 < x < 1.0
;   [prec] | [real] -> ()
plot ys =
    let n  = length ys
        ys = match ys
            ys : [prec] = map (flip (/) (maximum ys)    . (* (snd plotWindowSize))) ys
            ys : [real] = map ((* (snd plotWindowSize)) . rationalize . (* 0.5) . (+ 1.0)) ys
        plotMatrix (map (* (ceil (700 / n))) (0 .. n)) ys

plotf = plot . map rationalize


FUNCTION_CANVAS = class "vitry.runtime.util.FunctionCanvas"
COMPONENT       = class "java.awt.Component"
FRAME           = class "java.awt.Frame"
GRAPHICS        = class "java.awt.Graphics"
DRAW_POLYLINE   = method GRAPHICS "drawPolyline" [class "[I", class "[I", class "int"]
FRAME_ADD       = method FRAME "add" [COMPONENT]
FRAME_SET_SIZE  = method FRAME "setSize" [`int, `int]
FRAME_SHOW      = method FRAME "show" []
FRAME_DISPOSE   = method FRAME "dispose" []

window          = ref ()

plotMatrix xs ys =
    let zs       = map ((+ (snd plotWindowSize)) . negate) ys
        n        = min (length xs) (length ys)
        canvas   = new FUNCTION_CANVAS [paintPlot xs zs n]
        oldFrame = get window
        frame    = new FRAME ["Vitry"]
        do  FRAME_ADD frame canvas
            FRAME_SET_SIZE frame
                INT_PRIM (fst plotWindowSize + fst plotWindowPadding)
                INT_PRIM (snd plotWindowSize + snd plotWindowPadding)
            if  (oldFrame != nil)
                FRAME_DISPOSE oldFrame
                nil
            FRAME_SHOW frame
            set window frame
            nil

paintPlot xs ys n g =
    DRAW_POLYLINE g
        iarray xs
        iarray ys
        INT_PRIM n


; Output

fmsFile = fileDir ++ fileName ++ ".fms"
xmlFile = fileDir ++ fileName ++ ".xml"
lyFile  = fileDir ++ fileName ++ ".ly"


; Writes the given text to a file and displays it

export text = do
    writeFile fmsFile text
    if preview
        do run [ "fomus", fmsFile, "-o", lyFile ]
        do run [ "fomus", fmsFile, "-o", xmlFile ]
            if fixClefs
                do  print "adjusting fomus clefs..."
                    replaceFile xmlFile
                        [ "<sign>F</sign>", "<sign>C</sign>" ]
                        [ "<sign>F</sign><line>4</line>", "<sign>C</sign><line>3</line>" ]
                nil
            ; Open the score
            run [ "open", "-a", scoreEditor, xmlFile ]


; =============================================================================
; Layer and orchestration engine

; A layer is a sequence of frames, each of which has a duration
; and some attributes

dynamic    = double
saturation = double
resonance  = double

frame = (dur, range pitch, range dur, dynamic, saturation, resonance)
layer = [frame]

getFrameDur        (d, _,  _,  _, _, _) = d
getFramePitchRange (_, pr, _,  _, _, _) = pr
getFrameDurRange   (_, _,  dr, _, _, _) = dr
getFrameDynamic    (_, _,  _,  n, _, _) = n
getFrameSaturation (_, _,  _,  _, s, _) = s
getFrameResonance  (_, _,  _,  _, _, e) = e


; An orchestration is a list of parts, along with two functions
; to indicate its appropriateness for some frame, and a function
; to perform the orchestration.
;   - The predicate states an absolute condition for the
;     orchestration to be used, such as pitch range.
;   - The weigher states a relative appropriatness of the
;     orchestration based on its quality. A higher weighting
;     means that the orchestration is more likely to be chosen.
;   - The orchestrator performs the orchestration.

; FIXME we can not represent function types yet
; predicate    : frame -> boolean
; weighter     : frame -> double
; orchestrator : state -> frame -> (state, music)
predicate      = _
weighter       = _
orchestrator   = _
orchOptionType = `padding
orchOption     = (orchOptionType, (str | num | [str] | [num]))
orchestration  = ([part], predicate, weighter, orchestrator, [orchOption])
usage          = (dur, [part])
getUsageDur    = fst
getUsagePart   = snd

getParts          (r, p, w, o, t) = r
getPredicate      (r, p, w, o, t) = p
getWeighter       (r, p, w, o, t) = w
getOrchestrator   (r, p, w, o, t) = o
getOptions        (r, p, w, o, t) = t
setParts        r (_, p, w, o, t) = (r, p, w, o, t)
withParts f x = setParts (f (getParts x)) x


; [layer] -> [orchestration] -> music
orchestrate layers : [layer] orchs : [orchestration] =
    let offsets = take (length layers) (loop 0)
        delay orchestrate_ 0 offsets [] layers orchs

; [time] -> [usage] -> [layer] -> [orchestration] -> music
orchestrate_ lastOffset : int offsets : [time] usage : [usage] layers : [layer] orchs : [orchestration] =
    match offsets
        _ : [] = []

        _      = do  t = minimum offsets
                     i = findIndex (== t) offsets
                     match (index i layers)
                         _ : []  = do  offsets = remove i offsets
                                       usage   = remove i usage
                                       layers  = remove i layers
                                       orchestrate_ t offsets usage layers orchs
                         (f, fs) = do  offsets = updateOffsets t i (getFrameDur f) offsets
                                       usage   = updateUsage   (t - lastOffset) usage
                                       layers  = updateLayers  i fs layers

                                       let (usage, music) = orchestrateFrame usage f orchs
                                           offsetMusic t music ++ (delay orchestrate_ t offsets usage layers orchs)

; [usage] -> frame -> [orchestration] -> ([usage], music)

orchestrateFrame usage : [usage] frame : frame orchs : [orchestration] =
    let filterIllegal = id
                      . filter (somePartBusy usage)
                      . retain (acceptsFrame frame)

        orchs         = filterIllegal orchs

        match orchs
            _ : [] = do  warnNoOrchs ()
                         (usage, [])
            _      = do  weights = map   (weightFrame frame) orchs
                         orch    = index (maximumIndex weights) orchs

                         if (matches `orchestration verbose) then (printOrchs orchs weights) else nil

                         music = (getOrchestrator orch) frame
                         parts  = getParts orch
                         dur = match ((lookup `padding . getOptions) orch)
                             p : prec = getFrameDur frame + p
                             _        = getFrameDur frame
                         usage = prepend (dur, parts) usage
                         (usage, music)
                               
; TODO getUsagePart et al
updateOffsets t i d xs   = update i (index i xs + d) xs
updateUsage   t          = filter (fn (x) fst x <= 0) . map (fn (x) (fst x - t, snd x))
updateLayers  i fs       = update i fs

acceptsFrame frame       = (flip apply) frame . getPredicate
weightFrame frame        = (flip apply) frame . getWeighter
somePartBusy usage       = any (elementOf (flatten (map getUsagePart usage))) . getParts
warnNoOrchs _            = do  print "warning: no orchestration"
printOrchs orchs weights = do  print ("  orchs  : " ++ string (map (map getName) (map getParts orchs)))
                               print ("  weights: " ++ string weights)
flatten = foldr (++) []


; =============================================================================
; Main data

info   : [setting] = [ ("title",  "Skikt")
                     , ("author", "Hans Hoglund 2011") ]

header : [mark]    = [ ("tempo", "*1/4* = #", 90) ]
insts  : [inst]    = [ ("perc1", "percussion", [ "snare-drum", "bass-drum"
                                              , "crash-cymbal", "splash-cymbal" ]) ]

fl   : part = ("fl",   "flute",          [ ("abbr", "Fl.") ])
ob   : part = ("ob",   "oboe",           [ ("abbr", "Ob.") ])
cl   : part = ("cl",   "bflat-clarinet", [ ("abbr", "Kl.") ])
bsn  : part = ("bsn",  "bassoon",        [ ("abbr", "Fag.") ])
hrn  : part = ("hrn",  "horn",           [ ("abbr", "Hrn."), ("name", "Horn in F") ])
tpt  : part = ("tpt",  "bflat-trumpet",  [ ("abbr", "Tpt.") ])
tbn  : part = ("tbn",  "tenor-trombone", [ ("abbr", "Tbn.") ])
pno  : part = ("pno",  "piano",          [ ("abbr", "Pno.") ])
vib  : part = ("vib",  "vibraphone",     [ ("abbr", "Vib.") ])
crot : part = ("crot", "vibraphone",     [ ("abbr", "Crot."), ("name", "Crotales") ])
prc  : part = ("perc", "perc1",          [ ("abbr", "Perc."), ("name", "Percussion") ])
vl1  : part = ("vl1",  "violin",         [ ("abbr", "Vl. I") ])
vl2  : part = ("vl2",  "violin",         [ ("abbr", "Vl. II") ])
vla  : part = ("vla",  "viola",          [ ("abbr", "Vla.") ])
vc   : part = ("vc",   "cello",          [ ("abbr", "Vc."), ("name", "Violoncello") ])
db   : part = ("db",   "bass",           [ ("abbr", "Kb.") ])

parts : [part] = [ fl, ob, cl, bsn, hrn, tpt, tbn, pno, vib, crot, prc, vl1, vl2, vla, vc, db ]
decls : [decl] = insts ++ parts

percNote inst = match inst
    x : `bassDrum    = 65
    x : `snareDrum   = 72
    x : `smallCymbal = 76
    x : `largeCymbal = 79

curve1 = (sigToPos . take 70 . map (* 1.2) . sinG . mulG (line 470) . cosG) (line 70)
curve2 = (sigToPos . map negate . posToSig) curve1
curve3 = reverse curve1
curve4 = (sigToPos . take 70 . sinG . mulG (line 470) . cosG) (line 30)
curve5 = (sigToPos . take 70 . sinG . addG (map (* 0.1) (sinG (line 30)))) (line 180)
curve6 = (sigToPos . take 70 . sinG . (map (+ 0.11))) (line 180)
curve7 = (sigToPos . take 70 . sinG . (map (+ 0.3))) (line 100)
curve8 = (sigToPos . take 70 . sinG . (map (+ 0.7))) (line 100)
curve9 = (sigToPos . take 70 . sinG . addG (map (* 0.1) ((sinG . sinG) (line 60)))) (line 60)



; frame = (dur, range pitch, range dur, dynamic, saturation, resonance)

short = take 60
    zip6
        map (+ 1) (rands 5)
        loop (65, 67)
        loop (1/2, 1/2)

        line 70
        line 70
        loop 0.1

resonant = []
; resonant = take 70
;     zip6
;         loop 5
;         loop (55, 57)
;         loop (1/2, 1/2)
;
;         curve1
;         loop 0.1
;         loop 0.1

long = take 60
    let durs = map ((* 2) . (+ 1)) (rands 4)
        zip6
            durs
            zip (loop 60) (map ((+ 62) . (* 7) . rationalize) curve1)
            zip durs durs

            curve1
            curve1
            loop 0.0

layers = [short, resonant, long]




durRange   r = isOverlapping r . getFrameDurRange
pitchRange r = isOverlapping r . getFramePitchRange

stdWeight   f (_, _,  _,  n, s, e) = (f n s e)
stdOrch   r ir f (d, pr, dr, n, s, e) =
    do  range = (overlap ir pr)
        ; print range
        pitch = if (range == ()) (randomRange ir) else (randomRange range)
        map (f . setVoice [1, 2] . setPart r . setDyn n) (melody [randomRange dr] [pitch])


flutePizz                 = ( [fl], allPred [pitchRange (60, 93), durRange (0, 1 )]
                            , stdWeight (fn (dyn sat res)  sat )
                            , stdOrch fl (60, 93) (setMarks ["pizz"])
                            , [] )

fluteToungeRam            = ( [fl], allPred [pitchRange (60, 71), durRange (0, 1 )]
                            , stdWeight (fn (dyn sat res)  sat )
                            , stdOrch fl (60, 71) (setMarks [("x", "t-r.")])
                            , [] )

fluteShort                = ( [fl], allPred [pitchRange (60, 93), durRange (0, 1 )]
                            , (const 0.5)
                            , stdOrch fl (60, 93) (setMarks ["."])
                            , [] )

fluteContinuous           = ( [fl], allPred [pitchRange (60, 93), durRange (0, 12)]
                            , (const 0.5)
                            , stdOrch fl (60, 93) id
                            , [] )

fluteContinuousFlz        = ( [fl], allPred [pitchRange (60, 93), durRange (0, 12)]
                            , stdWeight (fn (dyn sat res)  sat )
                            , stdOrch fl (60, 93) (setMarks ["trem"])
                            , [] )

oboeShort                 = ( [ob], allPred [pitchRange (62, 88), durRange (0, 1 )]
                            , (const 0.5)
                            , stdOrch ob (62, 88) (setMarks ["."])
                            , [] )

flPlusOboe                = ( [fl, ob], allPred [pitchRange (62, 88), durRange (0, 12)]
                            , (const 0.9)
                            , (fn (f) (stdOrch fl (62, 88) id f) ++ (stdOrch ob (62, 88) id f))
                            , [(`padding, 2)] )

oboeContinuous            = ( [ob], allPred [pitchRange (62, 88), durRange (0, 12)]
                            , (const 0.5)
                            , stdOrch ob (62, 88) id
                            , [(`padding, 2)] )

clarinetShort             = ( [cl], allPred [pitchRange (50, 86), durRange (0, 1 )]
                            , (const 0.5)
                            , stdOrch cl (50, 86) (setMarks ["."])
                            , [] )

clarinetContinuous        = ( [cl], allPred [pitchRange (50, 86), durRange (0, 12)]
                            , (const 0.5)
                            , stdOrch cl (50, 86) id
                            , [] )

bassoonShort              = ( [bsn], allPred [pitchRange (34, 67), durRange (0, 1 )]
                            , (const 0.5)
                            , stdOrch bsn (34, 67) (setMarks ["."])
                            , [] )

bassoonContinuous         = ( [bsn], allPred [pitchRange (34, 67), durRange (0, 12)]
                            , (const 0.5)
                            , stdOrch bsn (34, 67) id
                            , [] )

; hornShort                 = ([hrn],      (48, 71),  (1, 1),  nil, nil)
; hornShortStopped          = ([hrn],      (48, 71),  (1, 1),  nil, nil)
; hornContinuous            = ([hrn],      (48, 71),  (1, 12), nil, nil)
; hornContinuousStopped     = ([hrn],      (48, 71),  (1, 12), nil, nil)
; trumpetShort              = ([tpt],      (53, 81),  (1, 1),  nil, nil)
; trumpetShortMute          = ([tpt],      (53, 81),  (1, 1),  nil, nil)
; trumpetContinuous         = ([tpt],      (53, 81),  (1, 1),  nil, nil)
; trumpetContinuousMute     = ([tpt],      (53, 81),  (1, 1),  nil, nil)
; trumpetContinuousHarmon   = ([tpt],      (53, 81),  (1, 1),  nil, nil)
; tromboneShort             = ([tbn],      (40, 69),  (1, 1),  nil, nil)
; tromboneShortMute         = ([tbn],      (40, 69),  (1, 1),  nil, nil)
; tromboneContinuous        = ([tbn],      (40, 69),  (1, 1),  nil, nil)
; tromboneContinuousMute    = ([tbn],      (40, 69),  (1, 1),  nil, nil)
; tromboneContinuousHarmon  = ([tbn],      (40, 69),  (1, 1),  nil, nil)
;
; pianoPizz                 = ([pno],      (21, 108), (1, 1),  nil, nil)
; pianoShort                = ([pno],      (21, 108), (1, 1),  nil, nil)
; pianoResonant             = ([pno],      (21, 108), (1, 1),  nil, nil)
; crotalesShort             = ([crot],     (60, 72),  (1, 1),  nil, nil)
; crotalesResonant          = ([crot],     (21, 108), (1, 8),  nil, nil)
; vibraphoneShort           = ([vib],      (53, 89),  (1, 1),  nil, nil)
; vibraphoneResonant        = ([vib],      (53, 89),  (1, 1),  nil, nil)
;
; bassDrumResonant          = ([prc],      (),        (1, 1),  nil, nil)
; bassDrumRoll              = ([prc],      (),        (1, 1),  nil, nil)
; snareDrumResonant         = ([prc],      (),        (1, 1),  nil, nil)
; snareDrumRoll             = ([prc],      (),        (1, 1),  nil, nil)
; largeCymbalResonant       = ([prc],      (),        (1, 1),  nil, nil)
; largeCymbalRoll           = ([prc],      (),        (1, 1),  nil, nil)
; woodblockShort            = ([prc],      (),        (1, 1),  nil, nil)
;
; violinBartokPizz          = ([vl1, vl2], (55, 91), (1, 1), nil, nil)
; violinPizz                = ([vl1, vl2], (55, 91), (1, 1), nil, nil)
; violinPizzHarm            = ([vl1, vl2], (55, 91), (1, 1), nil, nil)
; violinColLegnoBat         = ([vl1, vl2], (55, 91), (1, 1), nil, nil)
; violinContinous           = ([vl1, vl2], (55, 91), (1, 1), nil, nil)
; violinContinousTrem       = ([vl1, vl2], (55, 91), (1, 1), nil, nil)
; violinContinousHarm       = ([vl1, vl2], (55, 91), (1, 1), nil, nil)
; violaBartokPizz           = ([vla],      (55, 91), (1, 1), nil, nil)
; violaPizz                 = ([vla],      (48, 84), (1, 1), nil, nil)
; violaPizzHarm             = ([vla],      (48, 84), (1, 1), nil, nil)
; violaColLegnoBat          = ([vla],      (48, 84), (1, 1), nil, nil)
; violaContinous            = ([vla],      (48, 84), (1, 1), nil, nil)
; violaContinousTrem        = ([vla],      (48, 84), (1, 1), nil, nil)
; violaContinousHarm        = ([vla],      (48, 84), (1, 1), nil, nil)
; celloBartokPizz           = ([vc],       (36, 72), (1, 1), nil, nil)
; celloPizz                 = ([vc],       (36, 72), (1, 1), nil, nil)
; celloPizzHarm             = ([vc],       (36, 72), (1, 1), nil, nil)
; celloColLegnoBat          = ([vc],       (36, 72), (1, 1), nil, nil)
; celloContinous            = ([vc],       (36, 72), (1, 1), nil, nil)
; celloContinousTrem        = ([vc],       (36, 72), (1, 1), nil, nil)
; celloContinousHarm        = ([vc],       (36, 72), (1, 1), nil, nil)
; bassBartokPizz            = ([db],       (28, 52), (1, 1), nil, nil)
; bassPizz                  = ([db],       (28, 52), (1, 1), nil, nil)
; bassPizzHarm              = ([db],       (28, 52), (1, 1), nil, nil)
; bassColLegnoBat           = ([db],       (28, 52), (1, 1), nil, nil)
; bassContinous             = ([db],       (28, 52), (1, 1), nil, nil)
; bassContinousTrem         = ([db],       (28, 52), (1, 1), nil, nil)
; bassContinousHarm         = ([db],       (28, 52), (1, 1), nil, nil)
;
orchestrations   = [ flutePizz, fluteToungeRam, fluteShort, fluteContinuous, fluteContinuousFlz
                   , flPlusOboe
                   , oboeShort, oboeContinuous, clarinetShort, clarinetContinuous
                   ; , clarinetContinuousFlz
                   ; , bassClarinetShort, bassClarinetContinuous, bassClarinetContinuousFlz
                   , bassoonShort, bassoonContinuous ]
;
;                    , hornShort, hornShortStopped, hornContinuous, hornContinuousStopped, trumpetShort
;                    , trumpetShortMute, trumpetContinuous, trumpetContinuousMute, trumpetContinuousHarmon
;                    , tromboneShort, tromboneShortMute, tromboneContinuous, tromboneContinuousMute, tromboneContinuousHarmon
;
;                    , pianoPizz, pianoShort, pianoResonant, crotalesShort, crotalesResonant
;                    , vibraphoneShort, vibraphoneResonant
;
;                    , bassDrumResonant, bassDrumRoll, snareDrumResonant, snareDrumRoll
;                    , largeCymbalResonant, largeCymbalRoll, woodblockShort
;
;                    , violinBartokPizz, violinPizz, violinPizzHarm, violinColLegnoBat
;                    , violinContinous, violinContinousTrem, violinContinousHarm, violaBartokPizz, violaPizz
;                    , violaPizzHarm, violaColLegnoBat, violaContinous, violaContinousTrem, violaContinousHarm
;                    , celloBartokPizz, celloPizz, celloPizzHarm, celloColLegnoBat, celloContinous, celloContinousTrem
;                    , celloContinousHarm, bassBartokPizz, bassPizz, bassPizzHarm, bassColLegnoBat, bassContinous
;                    , bassContinousTrem, bassContinousHarm ]




events _ =
    do  print "resolving orchestration..."
        (x, xs) = orchestrate layers orchestrations
        if preview
            prepend (withMarks (++ header) x) xs
            prepend x xs

; Main program

printEvents _ = do force (map print (events nil))
                   nil
main _        = (export . fomus) (events nil, decls, info)
test _        = fomus (events nil, decls, info)
dump _        = join "\n" (events nil)


