; load "~/Documents/Musik/Skikt/Skikt.vitry"

; =============================================================================
; Skikt
; Hans Hoglund (2011)
; Vitry v0.1.2
; =============================================================================

module Hans.Music.Skikt

scoreEditor = "/Applications/Sibelius 6.app"
fileDir     = "/Users/hans/Documents/Musik/Skikt/output/"
fileName    = "out"
preview     = false
fixClefs    = false

info  = [ ("title",  "Skikt")
        , ("author", "Hans Hoglund 2011") ]

fl   = ( "fl",   "flute",          [ ("abbr", "Fl.") ])
ob   = ( "ob",   "oboe",           [ ("abbr", "Ob.") ])
cl   = ( "cl",   "bflat-clarinet", [ ("abbr", "Kl.") ])
bsn  = ( "bsn",  "bassoon",        [ ("abbr", "Fag.") ])
hrn  = ( "hrn",  "horn",           [ ("abbr", "Hrn.") ])
tpt  = ( "tpt",  "bflat-trumpet",  [ ("abbr", "Tpt.") ])
tbn  = ( "tbn",  "tenor-trombone", [ ("abbr", "Tbn.") ])
pno  = ( "pno",  "piano",          [ ("abbr", "Pno.") ])
vib  = ( "vib",  "vibraphone",     [ ("abbr", "Vib.") ])
crot = ( "crot", "vibraphone",     [ ("abbr", "Crot."), ("name", "Crotales") ])
prc  = ( "perc", "perc1",          [ ("abbr", "Perc."), ("name", "Percussion") ])
vl1  = ( "vl1",  "violin",         [ ("abbr", "Vl. I") ])
vl2  = ( "vl2",  "violin",         [ ("abbr", "Vl. II") ])
vla  = ( "vla",  "viola",          [ ("abbr", "Vla.") ])
vc   = ( "vc",   "cello",          [ ("abbr", "Vc."), ("name", "Violoncello") ])
db   = ( "db",   "bass",           [ ("abbr", "Kb.") ])

insts = [ ("perc1", "percussion", ["snare-drum", "bass-drum", "crash-cymbal", "splash-cymbal"]) ]
reson = ("reson", [(1, 1, "pno"), (1, 1, "vib")])

parts = [fl, ob, cl, bsn, hrn, tpt, tbn, pno, vib, crot, prc, vl1, vl2, vla, vc, db]
groups = [reson]
decls = insts ++ parts ++ groups

snareDrum = `snareDrum
bassDrum  = `bassDrum
smallCymbal = `smallCymbal 
largeCymbal = `largeCymbal

percNote inst = match inst
    x : bassDrum    = 65
    x : snareDrum   = 72
    x : smallCymbal = 76
    x : largeCymbal = 79




events _ =
    let durs    = map (+ 1) (rands 8)
        pitches = map (+ 60) (rands 10)               
        arts    = unroll (pluck pick [["."], ["-"]])
        notes   = zip5 (loop (1/2)) pitches noise arts (loop [])
        rests   = zip4 (loop "+") durs (loop []) (loop []) 
        events  = map (setPart vl1) (melody (interl notes rests)) 

    ; let durs    = map (+ 1) (rands 8)
    ;     pitches = map (+ 45) (rands 30)
    ;     notes   = zip5 (loop (1/2)) pitches (loop 0.5) (loop ["lv"]) (loop [])
    ;     rests   = zip4 (loop "+") durs (loop []) (loop []) 
    ;     events  = map (setPart reson) (melody (interl notes rests)) 

    
    ; let durs    = (loop (4 + 1/3))
    ;     pitches = (palindrome (60 .. 72)) 
    ;     dyns    = (cycle (map (approx . ((flip (/)) 4)) (0 .. 4))) 
    ;     notes   = zip5 durs pitches dyns (loop []) (loop [])
    ;     events = 
    ;         (map (setPart pno) . map (setMarks ["-"]) . melody)
    ;         notes   
        
        take 60 (cycle events)










noise = unfold (fn (x) (randomDouble (), 0)) 0

; Main program

main _ = (export . fomus) (events (), decls, info)
test _ = fomus (events (), decls, info)
dump _ = join "\n" (events ())




; =============================================================================
; FOMUS

; Interface to the FOMUS notation engine by David Psenicka
; See http://fomus.sourceforge.net/

; The workflow is to create a data structure representing a score
; and pass it to the fomus function. This function generates a
; text on a format understood by FOMUS, which may be written to
; a fms file.

; Fomus allows many fields to be "unset", assuming the previous value
; We represent this by nil

time       = nil | prec | "+"
grace      = nil | prec | "+"
dur        = nil | prec | "+" | "-"
pitch      = nil | prec
dyn        = nil | double
voice      = nil | int  | [int]

identifier = str
setting    = (str, (str | num | [str] | [num]))

markSign   = "(.." | "*" | "+" | "-" | "." | ".((." | ".(." | "..)" | "..))" | "..<"
           | "..>" | "." | "dash)" | "..dash))" | "..dot)" | "..dot))" | "..grace)"
           | "..ped" | "..tup" | "..x!" | "..x^" | "..x_" | ".<." | ".>." | ".dash((."
           | ".dash(." | ".dot((." | ".dot(." | ".grace(." | ".ped." | ".x!." | ".x^."
           | ".x_." | "/" | "/." | "0" | "<.." | ">" | ">.." | "^" | "arco" | "arp"
           | "arp^" | "arp_" | "artharm-base" | "artharm-sounding" | "artharm-touched"
           | "bellsup" | "break<" | "break>" | "breath" | "breath<" | "breath>"
           | "cuivre" | "damp" | "dash((.." | "dash(.." | "dot((.." | "dot(.."
           | "downbow" | "dyn" | "etouf" | "f" | "ferm" | "ferm-long" | "ferm-short"
           | "ferm-verylong" | "ff" | "fff" | "ffff" | "fffz" | "ffz" | "flaut" | "flt"
           | "fz" | "gliss<" | "gliss>" | "grace(.." | "leg" | "legno" | "longtr"
           | "longtr2" | "lv" | "mf" | "moltoleg" | "moltovib" | "mp" | "mute"
           | "natharm-sounding" | "natharm-string" | "natharm-touched" | "nonleg"
           | "nonvib" | "o" | "ord" | "p" | "ped.." | "pizz" | "pont" | "port<"
           | "port>" | "pp" | "ppp" | "pppp" | "ppppp" | "pppppp" | "punta" | "rf"
           | "rfz" | "ric" | "salt" | "sf" | "sff" | "sfff" | "sfffz" | "sffz" | "sfz"
           | "slap" | "snap" | "snappizz" | "spic" | "sul" | "table" | "tall" | "tasto"
           | "tempo" | "trem" | "trem2" | "tup.." | "unmute" | "upbow" | "vib" | "x"
           | "x!" | "x!.." | "x^" | "x^.." | "x_" | "x_.." | "~" | (`-) | (`.) | (`!) | (`+)

template   = identifier

clef    = [setting]
staff   = ([clef], [setting])

perc    = template
        | (identifier, [setting])
inst    = template
        | (identifier, template, [perc])
        | (identifier, template, [perc], [staff])
        | (identifier, template, [perc], [staff], [setting])

partmap = (voice, voice, identifier)
group   = (identifier, [partmap])
part    = (identifier, inst, [setting]) 
        | group 
        | nil

mark    = markSign
        | (markSign, (num | str))
        | (markSign, (num | str), (num | str))

; We define some sparse forms of the events for convenience

note    = (part,   voice,   time,    grace,   dur,     pitch,   dyn,     [mark],  [setting])
        | (part,   voice,   time,    dur,     pitch,   dyn,     [mark],  [setting])
        | (time,   dur,     pitch,   dyn,     [mark],  [setting])
        | (dur,    pitch,   dyn,     [mark],  [setting])
        | (pitch,  dyn,     [mark],  [setting])
rest    = (part,   voice,   time,    grace,   dur,     [mark],  [setting])
        | (time,   dur,     [mark],  [setting])
measure = (time,   dur,     [setting])
        | (dur,    [setting])

decl    = part | inst | group | perc | staff | clef
event   = note | rest | measure

score   = ( [event], [decl], [setting] )



; Utils

; Expands a sparse event to its complete form, substituting nil for all missing slots 
;   event -> event
expandEvent e : event = match e       
    (r, v, t, g, d, p, n, m, s)  : note    = e
    (r, v, t, d, p, n:dyn, m, s) : note    = (r,  v,  t,  (), d,  p, n, m, s)
    (t, d, p, n:dyn, m, s)       : note    = ((), (), t,  (), d,  p, n, m, s)
    (d, p, n:dyn, m, s)          : note    = ((), (), (), (), d,  p, n, m, s)
    (p, n:dyn, m, s)             : note    = ((), (), (), (), (), p, n, m, s)
    (p, v, t, g, d, m, s)        : rest    = e
    (t, d, m, s)                 : rest    = ((), (), t,  (), d,  m, s)
    (t, d, s)                    : measure = e
    (d, s)                       : measure = ((), d, s)

getNoteTime      (_, _, t, _, _, _, _, _, _) = t
getNoteDur       (_, _, _, _, d, _, _, _, _) = d
getNotePitch     (_, _, _, _, _, p, _, _, _) = p
getNoteDyn       (_, _, _, _, _, _, n, _, _) = n
getRestTime      (_, _, t, _, _, _, _)       = t
getRestDur       (_, _, _, _, d, _, _)       = d
getMeasureTime   (t, _, _)                   = t
getMeasureDur    (_, d, _)                   = d
setNotePart    r (_, v, t, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteVoice   v (r, _, t, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteTime    t (r, v, _, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteGrace   g (r, v, t, _, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteDur     d (r, v, t, g, _, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNotePitch   p (r, v, t, g, d, _, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteDyn     n (r, v, t, g, d, p, _, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteMarks   m (r, v, t, g, d, p, n, _, s) = (r, v, t, g, d, p, n, m, s)
setRestPart    r (_, v, t, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestVoice   v (r, _, t, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestTime    t (r, v, _, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestGrace   g (r, v, t, _, d, m, s)       = (r, v, t, g, d, m, s)
setRestDur     d (r, v, t, g, _, m, s)       = (r, v, t, g, d, m, s)
setRestMarks   m (r, v, t, g, d, _, s)       = (r, v, t, g, d, m, s)
setMeasureTime t (_, d, s)                   = (t, d, s)
setMeasureDur  d (t, _, s)                   = (t, d, s)


;   event -> dur
getTime e = match e
    e : note    = (getNoteTime . expandEvent) e
    e : rest    = (getRestTime . expandEvent) e
    e : measure = (getMeasureTime . expandEvent) e
getDur e = match e
    e : note    = (getNoteDur . expandEvent) e
    e : rest    = (getRestDur . expandEvent) e
    e : measure = (getMeasureDur . expandEvent) e

;   note -> pitch
getPitch = getNotePitch . expandEvent
getDyn   = getNoteDyn   . expandEvent

;   part | group -> id
getId x = match x
    (id, _, _) : part  = id
    (id, _)    : group = id

;   a -> event -> event    
setTime  x e =
    let set = match e (_ : note = setNoteTime) (_ : rest = setRestTime) (_ : measure = setMeasureTime)
        set x (expandEvent e)
setDur   x e = 
    let set = match e (_ : note = setNoteDur)  (_ : rest = setRestDur)  (_ : measure = setMeasureDur)
        set x (expandEvent e)
setPart  x e = 
    let set = match e (_ : note = setNotePart)  (_ : rest = setRestPart)
        set x (expandEvent e)
setVoice x e = 
    let set = match e (_ : note = setNoteVoice) (_ : rest = setRestVoice)
        set x (expandEvent e)
setGrace x e = 
    let set = match e (_ : note = setNoteGrace) (_ : rest = setRestGrace)
        set x (expandEvent e)
setMarks x e = 
    let set = match e (_ : note = setNoteMarks) (_ : rest = setRestMarks)
        set x (expandEvent e)
setPitch x e = setNotePitch x (expandEvent e)
setDyn   x e = setNoteDyn   x (expandEvent e)


;   [event] -> [event]
melody = map (setTime "+")
chord  = map (setTime nil)

;   dur -> [event] -> [event]
offset d = prepend ("+", d, [], [])


; Simple inspectors for the repl
    
declType d = match d
    d : part    = `part
    d : inst    = `inst
    d : perc    = `perc
    d : staff   = `staff
    d : clef    = `clef

eventType e = match e
    e : note    = `note
    e : rest    = `rest
    e : measure = `measure



; Export

; Returns a string representation of the given FOMUS data.
;    ( mark  |  decl  |  event  | setting | [mark] | [decl] | [event] | [setting] | score ) -> str
fomus data = match data
    (id, x, y)                : mark = "[" ++ string id ++ " " ++ fomus x ++ " " ++ fomus y ++ "]"
    (id, x)                   : mark = "[" ++ string id ++ " " ++ fomus x ++ "]"
    id                        : mark = "[" ++ string id ++ "]"
    
    (name, value)             : setting = name ++ "=" ++ fomus value
        
    (id, template, percs)     : inst = "inst <"
                                    ++ "id="        ++ id              ++ " " 
                                    ++ "template="  ++ fomus template  ++ " " 
                                    ++ "percinsts=" ++ fomusList percs ++ ">"
    (id, inst, settings)      : part = "part <"
                                    ++ "id="   ++ id         ++ " " 
                                    ++ "inst=" ++ fomus inst ++ " " 
                                    ++ fomus settings        ++ ">"
    (id, partmaps)            : group = "metapart <"
                                    ++ "id="    ++ string id          ++ " "
                                    ++ "parts=" ++ fomusList partmaps ++ ">"
    (from, to, id)            : partmap = "<"
                                    ++ "from-voice=" ++ string from ++ " "
                                    ++ "to-voice="   ++ string to   ++ " "
                                    ++ "part="       ++  string id  ++ ">"                                    
    
    (part, voice, time, grace, dur, pitch, dyn, marks, settings) : note = ""
                                    ++ maybePart part   ++ " " 
                                    ++ maybeVoice voice ++ " " 
                                    ++ maybeTime time   ++ " " 
                                    ++ maybeGrace grace ++ " " 
                                    ++ maybeDur dur     ++ " " 
                                    ++ maybePitch pitch ++ " " 
                                    ++ maybeDynamic dyn ++ " " 
                                    ++ fomus marks      ++ " " 
                                    ++ fomus settings   ++ ";"
    (part, voice, time, grace, dur, marks, settings) : rest = "rest "
                                    ++ maybePart part   ++ " " 
                                    ++ maybeVoice voice ++ " " 
                                    ++ maybeTime time   ++ " " 
                                    ++ maybeGrace grace ++ " " 
                                    ++ maybeDur dur     ++ " " 
                                    ++ fomus marks      ++ " " 
                                    ++ fomus settings   ++ ";"
    (time, dur, settings)     : measure = ""
                                    ++ maybeTime time   ++ " "
                                    ++ maybeDur  dur    ++ " "
                                    ++ "measure <" ++ fomus settings ++ ">"
    event                     : event = (fomus . expandEvent) event

    (events, decls, settings) : score = join "\n\n" [fomus settings, fomus decls, fomus events]

    settings : [setting]    = join " " (map fomus settings)
    marks    : [mark]       = join " " (map fomus marks)
    event    : [event]      = join "\n" (map fomus event)
    decls    : [decl]       = join "\n" (map fomus decls)
    x        : str          = fomusStr x
    x        : num          = string x
    x        : ()           = ""
    xs       : [_]          = fomusList xs


fomusList xs = "(" ++ join " " (map fomus xs) ++ ")"
fomusStr x   = "\"" ++ x ++ "\""

maybePart x    = match x (x : () = "") (x = "part="    ++ getId x)
maybeVoice x   = match x (x : () = "") (x = "voice="   ++ string x)
maybeTime x    = match x (x : () = "") (x = "time="    ++ string x)
maybeGrace x   = match x (x : () = "") (x = "grace="   ++ string x)
maybeDur x     = match x (x : () = "") (x = "dur="     ++ string x)
maybePitch x   = match x (x : () = "") (x = "pitch="   ++ string x)
maybeDynamic x = match x (x : () = "") (x = "dynamic=" ++ string x)



; =============================================================================
; Output

fmsFile = fileDir ++ fileName ++ ".fms"
xmlFile = fileDir ++ fileName ++ ".xml"
lyFile  = fileDir ++ fileName ++ ".ly"


; Writes the given text to a file and displays it

export text = do
    writeFile fmsFile text
    if preview
        do run [ "fomus", fmsFile, "-o", lyFile ]
        ; else
        do run [ "fomus", fmsFile, "-o", xmlFile ]
            if fixClefs 
                do print "adjusting fomus clefs..."
                    replaceFile xmlFile
                        [ "<sign>F</sign>", "<sign>C</sign>" ]
                        [ "<sign>F</sign><line>4</line>", "<sign>C</sign><line>3</line>" ]
                ; else
                ()
            ; Open the score
            run [ "open", "-a", scoreEditor, xmlFile ]
