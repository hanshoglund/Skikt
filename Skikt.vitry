; load "~/Documents/Musik/Skikt/Skikt.vitry"

; =============================================================================
; Skikt
; Hans Hoglund (2011)
; Vitry v0.1.2
; =============================================================================

module Hans.Music.Skikt

scoreEditor      = "/Applications/Sibelius 6.app"
fileDir          = "/Users/hans/Documents/Musik/Skikt/output/"
fileName         = "out"
preview          = false
fixClefs         = false
verbose          = `output 
                 ; & `orchestration
nonDeterministic = nil 
                 & `orchestration
minDynLevel      = 0.1

; =============================================================================
; FOMUS

; module Music.Fomus

; Interface to the FOMUS notation engine by David Psenicka
; See http://fomus.sourceforge.net/

; The workflow is to create a data structure representing a score
; and pass it to the fomus function. This function generates a
; text on a format understood by Fomus, which may be written to
; a fomus text file.

time     = nil | prec | "+"
grace    = nil | prec | "+"
dur      = nil | prec | "+" | "-"
pitch    = nil | prec
dyn      = nil | double
voice    = nil | int  | [int]
fomusId  = str

markType = "(.." | "*" | "+" | "-" | "." | ".((." | ".(." | "..)" | "..))" | "..<"
         | "..>" | "." | "..dash)" | "..dash))" | "..dot)" | "..dot))" | "..grace)"
         | "..ped" | "..tup" | "..x!" | "..x^" | "..x_" | ".<." | ".>." | ".dash((."
         | ".dash(." | ".dot((." | ".dot(." | ".grace(." | ".ped." | ".x!." | ".x^."
         | ".x_." | "/" | "/." | "0" | "<.." | ">" | ">.." | "^" | "arco" | "arp"
         | "arp^" | "arp_" | "artharm-base" | "artharm-sounding" | "artharm-touched"
         | "bellsup" | "break<" | "break>" | "breath" | "breath<" | "breath>"
         | "cuivre" | "damp" | "dash((.." | "dash(.." | "dot((.." | "dot(.."
         | "downbow" | "dyn" | "etouf" | "f" | "ferm" | "ferm-long" | "ferm-short"
         | "ferm-verylong" | "ff" | "fff" | "ffff" | "fffz" | "ffz" | "flaut" | "flt"
         | "fz" | "gliss<" | "gliss>" | "grace(.." | "leg" | "legno" | "longtr"
         | "longtr2" | "lv" | "mf" | "moltoleg" | "moltovib" | "mp" | "mute"
         | "natharm-sounding" | "natharm-string" | "natharm-touched" | "nonleg"
         | "nonvib" | "o" | "ord" | "p" | "ped.." | "pizz" | "pont" | "port<"
         | "port>" | "pp" | "ppp" | "pppp" | "ppppp" | "pppppp" | "punta" | "rf"
         | "rfz" | "ric" | "salt" | "sf" | "sff" | "sfff" | "sfffz" | "sffz" | "sfz"
         | "slap" | "snap" | "snappizz" | "spic" | "sul" | "table" | "tall" | "tasto"
         | "tempo" | "trem" | "trem2" | "tup.." | "unmute" | "upbow" | "vib" | "x"
         | "x!" | "x!.." | "x^" | "x^.." | "x_" | "x_.." | "~" | (`-) | (`.) | (`!) | (`+)

mark     = markType
         | (markType, (num | str))
         | (markType, (num | str), (num | str))

setting  = (str, (str | num | [str] | [num]))

clef     = [setting]
staff    = ([clef],  [setting])
template = fomusId
percInst = fomusId
         | (fomusId, [setting])
inst     = fomusId
         | (fomusId, template, [percInst], [staff], [setting])
         | (fomusId, template, [percInst])
partMap  = (voice, voice, fomusId)
metaPart = (fomusId, [partMap])
part     = nil
         | metaPart
         | (fomusId, inst, [setting])
note     = (part, voice, time, grace, dur, pitch, dyn, [mark], [setting])
         | (part, voice, time, dur, pitch, dyn, [mark], [setting])
         | (time, dur, pitch, dyn, [mark], [setting])
         | (dur, pitch, dyn, [mark], [setting])
         | (pitch, dyn, [mark], [setting])
rest     = (part, voice, time, grace, dur, [mark], [setting])
         | (time, dur, [mark], [setting])
meas     = (time, dur, [setting])
         | (dur, [setting])

decl     = part | inst | metaPart | percInst | staff | clef
event    = note | rest | meas

music    = [event]
         | (`par, _, _)
         | (`seq, _, _)

score    = (music, [decl], [setting])


expandEvent e : event = match e
    (r, v, t, g, d, p, n, m, s)  : note = e
    (r, v, t, d, p, n:dyn, m, s) : note = (r,  v,  t,  (), d,  p, n, m, s)
    (t, d, p, n:dyn, m, s)       : note = ((), (), t,  (), d,  p, n, m, s)
    (d, p, n:dyn, m, s)          : note = ((), (), (), (), d,  p, n, m, s)
    (p, n:dyn, m, s)             : note = ((), (), (), (), (), p, n, m, s)
    (p, v, t, g, d, m, s)        : rest = e
    (t, d, m, s)                 : rest = ((), (), t,  (), d,  m, s)
    (t, d, s)                    : meas = e
    (d, s)                       : meas = ((), d, s)

getNotePart    (r, _, _, _, _, _, _, _, _) = r
getNoteVoice   (_, v, _, _, _, _, _, _, _) = v
getNoteTime    (_, _, t, _, _, _, _, _, _) = t
getNoteGrace   (_, _, _, g, _, _, _, _, _) = g
getNoteDur     (_, _, _, _, d, _, _, _, _) = d
getNotePitch   (_, _, _, _, _, p, _, _, _) = p
getNoteDyn     (_, _, _, _, _, _, n, _, _) = n
getNoteMarks   (_, _, _, _, _, _, _, m, _) = m
getRestPart    (r, _, _, _, _, _, _)       = r
getRestVoice   (_, v, _, _, _, _, _)       = v
getRestTime    (_, _, t, _, _, _, _)       = t
getRestGrace   (_, _, _, g, _, _, _)       = g
getRestDur     (_, _, _, _, d, _, _)       = d
getRestMarks   (_, _, _, _, _, m, _)       = m
getMeasTime    (t, _, _)                   = t
getMeasDur     (_, d, _)                   = d
setNotePart  r (_, v, t, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteVoice v (r, _, t, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteTime  t (r, v, _, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteGrace g (r, v, t, _, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteDur   d (r, v, t, g, _, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNotePitch p (r, v, t, g, d, _, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteDyn   n (r, v, t, g, d, p, _, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteMarks m (r, v, t, g, d, p, n, _, s) = (r, v, t, g, d, p, n, m, s)
setRestPart  r (_, v, t, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestVoice v (r, _, t, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestTime  t (r, v, _, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestGrace g (r, v, t, _, d, m, s)       = (r, v, t, g, d, m, s)
setRestDur   d (r, v, t, g, _, m, s)       = (r, v, t, g, d, m, s)
setRestMarks m (r, v, t, g, d, _, s)       = (r, v, t, g, d, m, s)
setMeasTime  t (_, d, s)                   = (t, d, s)
setMeasDur   d (t, _, s)                   = (t, d, s)

; event -> dur
getTime e = match e
    e : note = (getNoteTime . expandEvent) e
    e : rest = (getRestTime . expandEvent) e
    e : meas = (getMeasTime . expandEvent) e
getDur e = match e
    e : note = (getNoteDur . expandEvent) e
    e : rest = (getRestDur . expandEvent) e
    e : meas = (getMeasDur . expandEvent) e
getPart e = match e
    e : note = (getNotePart . expandEvent) e
    e : rest = (getRestPart . expandEvent) e
getVoice e = match e
    e : note = (getNoteVoice . expandEvent) e
    e : rest = (getRestVoice . expandEvent) e
getGrace e = match e
    e : note = (getNoteGrace . expandEvent) e
    e : rest = (getRestGrace . expandEvent) e
getMarks e = match e
    e : note = (getNoteMarks . expandEvent) e
    e : rest = (getRestMarks . expandEvent) e

; event -> prec |Â "+"
getActualDur x = if (getTime x == ()) then 0 else (getDur x)

; note -> pitch
getPitch = getNotePitch . expandEvent
getDyn   = getNoteDyn   . expandEvent

; part | metaPart -> id
getName x = match x
    (id, _, _) : part  = id
    (id, _)    : metaPart = id

; a -> event -> event
setTime   x e = match e
    e : note = setNoteTime  x (expandEvent e)
    e : rest = setRestTime  x (expandEvent e)
    e : meas = setMeasTime  x (expandEvent e)
setDur    x e = match e
    e : note = setNoteDur   x (expandEvent e)
    e : rest = setRestDur   x (expandEvent e)
    e : meas = setMeasDur   x (expandEvent e)
setPart   x e = match e
    e : note = setNotePart  x (expandEvent e)
    e : rest = setRestPart  x (expandEvent e)
setVoice  x e = match e
    e : note = setNoteVoice x (expandEvent e)
    e : rest = setRestVoice x (expandEvent e)
setGrace  x e = match e
    e : note = setNoteGrace x (expandEvent e)
    e : rest = setRestGrace x (expandEvent e)
setMarks  x e = match e
    e : note = setNoteMarks x (expandEvent e)
    e : rest = setRestMarks x (expandEvent e)
setPitch  x e = setNotePitch x (expandEvent e)
setDyn    x e = setNoteDyn   x (expandEvent e)

withTime  f x = setTime  (f (getTime  x)) x
withDur   f x = setDur   (f (getDur   x)) x
withPart  f x = setPart  (f (getPart  x)) x
withVoice f x = setVoice (f (getVoice x)) x
withGrace f x = setGrace (f (getGrace x)) x
withMarks f x = setMarks (f (getMarks x)) x
withPitch f x = setPitch (f (getPitch x)) x
withDyn   f x = setDyn   (f (getDyn   x)) x
addMark m = withMarks (prepend m)

; Time and duration is context-sensitive in Fomus. This means that we
; can get unexpected results when assembling events from various sources.

; To counter the problem we introduce normal-form event lists which are
; unaffected by surrounding events
;
; Normal form events lists take three shapes:
;   - Relative, where
;       - durations are given explitly
;       - the first time value is a number
;       - all other time values are "+" or nil
;   - Absolute, where
;       - time values are given explitly
;       - the last duration is a number
;       - and all other durations are "+" or nil
;   - Explicit, where
;       - all time values and durations are given explitly

assureTimeAndDur t nt d nd event =
    match (getTime event, getDur event)
        (_ : nt, _     ) = false
        (_,      _ : nd) = false
        (_ : t,  _ : d ) = true
        _                = false

; event -> bool
isRelativeEvent = assureTimeAndDur ("+" | ()) {}         _          ("+" | ())
isAbsoluteEvent = assureTimeAndDur _          ("+" | ()) ("+" | ()) {}
isExplicitEvent = assureTimeAndDur _          ("+" | ()) _          ("+" | ())

; [event] -> bool
isRelative xs = match xs
    _ : [] = true
    xs     = isExplicitEvent (head xs) && (all isRelativeEvent) (tail xs)
isAbsolute xs = match xs
    _ : [] = true
    xs     = isExplicitEvent (last xs) && (all isAbsoluteEvent) (init xs)
isExplicit = all isExplicitEvent

isInNormalForm xs = isRelative xs || isAbsolute xs || isExplicit xs


; Basic event lists builders

; [time] -> [dur] -> [pitch] -> [note]
notes times durs pitches = zip6 times durs pitches (loop 0.5) (loop []) (loop [])

; [time] -> [dur] -> [note]
rests times durs         = zip4 times durs (loop []) (loop [])



; The following functions generates music in relative form

; [dur] -> [pitch] -> [note]
melody durs pitches = match (durs, pitches)
    _ : [], _        = []
    _,      _ : []   = []
    (d, ds), (p, ps) = prepend (0, d, p, 0.5, [], []) (delay notes (loop "+") ds ps)

chordT time dur pitches = match pitches
    _ : []  = []
    (p, ps) = prepend (time, dur, p, 0.5, [], []) (delay notes (loop nil) (loop dur) ps)
chordsT time1 time2 durs pitches = match (durs, pitches)
    _ : [], _        = []
    _,      _ : []   = []
    (d, ds), (p, ps) = (delay chordT time1 d p ++ chordsT time2 time2 ds ps)
chordsI time1 time2 durs pitches interl = match (durs, pitches, interl)
    _ : [], _,      _         = []
    _,      _ : [], _         = []
    _,      _,      _ : []    = []
    (d, ds), (p, ps), (i, is) = (delay chordT time1 d p ++ [i] ++ chordsI time2 time2 ds ps is)

; dur -> [pitch] -> [note]
chord = chordT 0

; [dur] -> [[pitch]] -> [note]
chords = chordsT 0 "+"

; [mark] -> [mark] -> [mark] -> [note] -> [note]
phraseNotes attack sustain release notes = match notes
    _ : ()      = () 
    (x, _ : ()) = [setMarks attack x]
    _           = [setMarks attack (head notes)]
                  ++ map (setMarks sustain) ((init . tail) notes)
                  ++ [setMarks release (last notes)]

; [mark] -> [mark] -> [mark] -> [dur] -> [pitch]
phrase attack sustain release       = phraseNotes attack sustain release .' melody
; [mark] -> [mark] -> [mark] -> [dur] -> [[pitch]]
chordsPhrase attack sustain release = phraseNotes attack sustain release .' chords
; [mark] -> dur -> [pitch]
chordPhrase marks                   = phraseNotes marks marks marks .' chord

legato               = phrase ["(.."] [".(."] ["..)"]
accentLegato         = phrase ["(..", ">"] [".(."] ["..)"]
legatoAccent         = phrase ["(.."] [".(."] ["..)", ">"]
legatoAccentStaccato = phrase ["(.."] [".(."] ["..)", ".", ">"]
legatoStaccato       = phrase ["(.."] [".(."] ["..)", "."]
legatoTenuto         = phrase ["(.."] [".(."] ["..)", "-"]
dashedLegato         = phrase ["dash(.."] [".dash(."] ["..dash)"]
dottedLegato         = phrase ["dot(.."] [".dot(."] ["..dot)"]
staccato             = phrase ["."] ["."] ["."]
tenuto               = phrase ["-"] ["-"] ["-"]
staccatoTenuto       = phrase ["-", "."] ["-", "."] ["-", "."]
portato              = phrase ["(..", "."] [".(.", "."] ["..)", "."]
moltoPortato         = phrase ["(..", "-"] [".(.", "-"] ["..)", "-"]
pizz                 = phrase ["pizz"] ["pizz"] ["pizz"]
snap                 = phrase ["snap"] ["snap"] ["snap"]

chordArp             = chordsPhrase ["arp"]
chordArpUp           = chordsPhrase ["arp^"]
chordArpDown         = chordsPhrase ["arp_"]
chordsArp            = chordsPhrase ["arp"] ["arp"] ["arp"]
chordsArpUp          = chordsPhrase ["arp^"] ["arp^"] ["arp^"]
chordsArpDown        = chordsPhrase ["arp_"] ["arp_"] ["arp_"]

chordsLegato         = chordsPhrase ["(.."] [] ["..)"]
chordsDashedLegato   = chordsPhrase ["dash(.."] [] ["..dash)"]
chordsDottedLegato   = chordsPhrase ["dot(.."] [] ["..dot)"]
chordsStaccato       = chordsPhrase ["."] ["."] ["."]
chordsTenuto         = chordsPhrase ["-"] ["-"] ["-"]
chordsPortato        = chordsPhrase ["(..", "."] ["."] ["..)", "."]
chordsMoltoPortato   = chordsPhrase ["-", "."] ["-", "."] ["-", "."]


; [dur] -> [dur] -> [pitch] -> [event]
restMelody durs restDurs pitches =
    interl (melody durs pitches) (rests (loop "+") restDurs)

; [mark] -> [mark] -> [mark] -> [dur] -> [dur] -> [pitch] -> [event]
restPhrase attack sustain release durs restDurs pitches =
    interl (phrase attack sustain release durs pitches) (rests (loop "+") restDurs)

; ; [dur] -> [dur] -> [[pitch]] -> [note]
restChords durs restDurs pitches =
    chordsI 0 "+" durs pitches (rests (loop "+") restDurs)

; [mark] -> [mark] -> [mark] -> [dur] -> [dur] -> [[pitch]]
restChordsPhrase attack sustain release = phraseNotes attack sustain release .'' restChords

; [dur] -> [dur] -> [pitch] -> [event]
restLegato               = restPhrase ["(.."] [".(."] ["..)"]
restDashedLegato         = restPhrase ["dash(.."] [".dash(."] ["..dash)"]
restDottedLegato         = restPhrase ["dot(.."] [".dot(."] ["..dot)"]
restStaccato             = restPhrase ["."] ["."] ["."]
restTenuto               = restPhrase ["-"] ["-"] ["-"]
restPortato              = restPhrase ["(..", "."] [".(.", "."] ["..)", "."]
restMoltoPortato         = restPhrase ["-", "."] ["-", "."] ["-", "."]

restChordArp             = restChordsPhrase ["arp"]
restChordArpUp           = restChordsPhrase ["arp^"]
restChordArpDown         = restChordsPhrase ["arp_"]
restChordsArp            = restChordsPhrase ["arp"] ["arp"] ["arp"]
restChordsArpUp          = restChordsPhrase ["arp^"] ["arp^"] ["arp^"]
restChordsArpDown        = restChordsPhrase ["arp_"] ["arp_"] ["arp_"]

restChordsLegato         = restChordsPhrase ["(.."] [] ["..)"]
restChordsDashedLegato   = restChordsPhrase ["dash(.."] [] ["..dash)"]
restChordsDottedLegato   = restChordsPhrase ["dot(.."] [] ["..dot)"]
restChordsStaccato       = restChordsPhrase ["."] ["."] ["."]
restChordsTenuto         = restChordsPhrase ["-"] ["-"] ["-"]
restChordsPortato        = restChordsPhrase ["(..", "."] ["."] ["..)", "."]
restChordsMoltoPortato   = restChordsPhrase ["-", "."] ["-", "."] ["-", "."]



; The music type allow us to sequence events in an abstract fashion

; music -> music -> music
sequence a b = (`seq, a, b)
parallel a b = (`par, a, b)

; time -> [event] -> [event]
offsetMusic time = map (withTime (fn (x) match x (x : prec = x + time) (_ = x)))

; music -> dur
duration m = match m
    (_ : `seq, a, b) = (+) (duration a) (duration b)
    (_ : `par, a, b) = max (duration a) (duration b)
    m : [event]      = (getTime . head) m + (sum . map getActualDur) m

; music -> [event]
musicToEvents m = match m
    (_ : `seq, a, b) = musicToEvents a ++ offsetMusic (duration a) (musicToEvents b)
    (_ : `par, a, b) = musicToEvents a ++ musicToEvents b
    m : [event]      = m

mapMusic f m = match m
    (_ : `seq, a, b) = (`seq, mapMusic f a, mapMusic f b)
    (_ : `par, a, b) = (`par, mapMusic f a, mapMusic f b)
    m : [event]      = map f m



; Simple inspectors for the repl

declType d = match d
    d : part     = `part
    d : inst     = `inst
    d : percInst = `percInst
    d : staff    = `staff
    d : clef     = `clef

eventType e = match e
    e : note     = `note
    e : rest     = `rest
    e : meas     = `meas


; Main export function
; Converts the given data structure to a text format understood by Fomus.
;    ( mark  |  decl  |  event  | setting | [mark] | [decl] | [event] | [setting] | score ) -> str

fomus data = match data
    (id, x, y)                : mark = "[" ++ string id ++ " " ++ fomus x ++ " " ++ fomus y ++ "]"
    (id, x)                   : mark = "[" ++ string id ++ " " ++ fomus x ++ "]"
    id                        : mark = "[" ++ string id ++ "]"

    (name, value)             : setting = name ++ "=" ++ fomus value

    (id, template, percInsts) : inst = "inst <"
                                    ++ "id="        ++ id              ++ " "
                                    ++ "template="  ++ fomus template  ++ " "
                                    ++ "percinsts=" ++ fomusList percInsts ++ ">"
    (id, inst, settings)      : part = "part <"
                                    ++ "id="   ++ id         ++ " "
                                    ++ "inst=" ++ fomus inst ++ " "
                                    ++ fomus settings        ++ ">"
    (id, partMaps)            : metaPart = "metapart <"
                                    ++ "id="    ++ string id          ++ " "
                                    ++ "parts=" ++ fomusList partMaps ++ ">"
    (from, to, id)            : partMap = "<"
                                    ++ "from-voice=" ++ string from ++ " "
                                    ++ "to-voice="   ++ string to   ++ " "
                                    ++ "part="       ++  string id  ++ ">"

    (part, voice, time, grace, dur, pitch, dyn, marks, settings) : note = "note "
                                    ++ maybePart part   ++ " "
                                    ++ maybeVoice voice ++ " "
                                    ++ maybeTime time   ++ " "
                                    ++ maybeGrace grace ++ " "
                                    ++ maybeDur dur     ++ " "
                                    ++ maybePitch pitch ++ " "
                                    ++ maybeDynamic dyn ++ " "
                                    ++ fomus marks      ++ " "
                                    ++ fomus settings   ++ ";"
    (part, voice, time, grace, dur, marks, settings) : rest = "rest "
                                    ++ maybePart part   ++ " "
                                    ++ maybeVoice voice ++ " "
                                    ++ maybeTime time   ++ " "
                                    ++ maybeGrace grace ++ " "
                                    ++ maybeDur dur     ++ " "
                                    ++ fomus marks      ++ " "
                                    ++ fomus settings   ++ ";"
    (time, dur, settings)     : meas = ""
                                    ++ maybeTime time   ++ " "
                                    ++ maybeDur  dur    ++ " "
                                    ++ "meas <" ++ fomus settings ++ ">"
    event                     : event = (fomus . expandEvent) event

    (events, decls, settings) : score = join "\n\n" [fomus settings, fomus decls, fomus events]

    settings : [setting]    = join " " (map fomus settings)
    marks    : [mark]       = join " " (map fomus marks)
    event    : [event]      = join "\n" (map fomus event)
    decls    : [decl]       = join "\n" (map fomus decls)
    music    : music        = (fomus . musicToEvents) music
    x        : str          = fomusStr x
    x        : num          = string x
    x        : ()           = ""
    xs       : [_]          = fomusList xs


fomusList xs = "(" ++ join " " (map fomus xs) ++ ")"
fomusStr x   = "\"" ++ x ++ "\""

maybePart x    = match x (x : () = "") (x = "part="    ++ getName x)
maybeVoice x   = match x (x : () = "") (x = "voice="   ++ listOrString x)
maybeTime x    = match x (x : () = "") (x = "time="    ++ string x)
maybeGrace x   = match x (x : () = "") (x = "grace="   ++ string x)
maybeDur x     = match x (x : () = "") (x = "dur="     ++ string x)
maybePitch x   = match x (x : () = "") (x = "pitch="   ++ string x)
maybeDynamic x = match x (x : () = "") (x = "dynamic=" ++ string x)
listOrString x = match x (x : [_] = fomusList x) (_ = string x)




; =============================================================================
; Util


firstLast xs = [head xs, last xs]
tessitura xs = match xs
    _ : []       = [60]
    (x, xs : []) = [x, x]
    (x, xs)      = [x, last xs]
        

; Ranges
; An inclusive range (interval)

range a = (a, a)

; range a -> [a]
enumerate (a, b) = (a .. succ b)

; range a -> range a | ()
overlap (a, b) (c, d) =
    if  (a > b || c > d) then nil else
        let x = max a c
            y = min b d
            if  (x > y) then nil else (x, y)

; a -> range a -> bool
inRange    (a, b) x      = a <= x && x <= b
isSubRange (a, b) (c, d) = c <= a && b <= d
isOverlapping            = (!= ()) .' overlap

mapRange f (a, b) = (f a, f b)

; range prec -> range real-> [prec] -> [prec]
retainScaledRange (c, d) (a, b) = 
                    do  c = approx c
                        d = approx d
                        delta = d - c
                        retain (inRange (round (a * delta + c), round (b * delta + c)))

; range int -> [a] -> [a]
indexRange (a, b) = substr a (succ b - a)

; range real -> [a] -> [a]
clip (a, b) xs    = let n = approx $ length xs
                        indexRange (round (a * n), round (b * n)) xs


; Musical structures

modeFrom xs range = fn (i) 
    index (i % length xs) xs + floor (i / length xs) * range

diatonic = modeFrom [0, 2, 4, 5, 7, 9, 11] 12



; Probability

gauss    x = (1.0 / sqrt (2.0 * pi) * e) ^ (- (0.5 * x ^ 2.0))

; Returns 1.0 for the center value and a value < 1.0 for off-center values
; With should typicaly be 10.0 < x < 50.0
; double -> double -> double
gaussian center width = gauss . (* width) . (+ negate center)


; Curves

; int -> ([float] -> [float]) -> [float]
curve length f = take length . sigToPos . f $ line length

noise  = unfold (fn (x) (randomDouble () * 2.0 - 1.0, 0)) 0
line n = cycle (map (approx . flip (/) n) (0 .. n))
sinG   = map (sin . (* 2.0 * pi))
cosG   = map (cos . (* 2.0 * pi))
addG   = zipWith (+)
mulG   = zipWith (*)



; Returns a list of length n approximating the values of the given list.
; Returns the original list if its length is >= n
;   int -> [prec] -> [prec] | [real] -> [real]
sample n     = map head . partitionInto n
sampleMean n = map mean . partitionInto n  


mean2 x y   = mean [x, y]
mean3 x y z = mean [x, y, z]


; Returns a list of length n by interpolating
; Returns the original list if its length is < n
; interpolate n = 


;   int -> [prec] -> [prec] | [real] -> [real]
; interpolate n =

sigToPos = map (fn (x) (x + 1.0) / 2.0)
posToSig = map (fn (x) x * 2.0 - 1.0)


; Plotting

point = (prec, prec)

plotWindowSize    : point = (700, 200)
plotWindowPadding : point = (0, 23)

; Displays a simple plot of the given list of numbers in a window
; Precise numbers may be of any magnitude
; Real numbers are assumed to be in the range -1.0 < x < 1.0
;   [prec] | [real] -> ()
plot ys =
    let n  = length ys    
        xs = map (* (ceil $ fst plotWindowSize / n)) (0 .. n)
        ys = match ys
            ys : [prec] = map ((* snd plotWindowSize) . flip (/) (maximum ys)) ys
            ys : [real] = map ((* snd plotWindowSize) . rationalize . (* 0.5) . (+ 1.0)) ys
        drawCurve $ zip xs ys

; Plot floats in range 0.0 < 1.0 instead of -1.0 < x 1.0
;   [real] -> ()
plotf = plot . posToSig

window          = ref ()
                                                         
; Draw a sequence of points 
; (0, 0) is lower left corner, plotWindowSize is upper right
;   [point] -> ()
drawCurve points : [point] =                             
    let FUNCTION_CANVAS = class "vitry.runtime.util.FunctionCanvas"
        COMPONENT       = class "java.awt.Component"
        FRAME           = class "java.awt.Frame"
        GRAPHICS        = class "java.awt.Graphics"
        FRAME_ADD       = method FRAME "add" [COMPONENT]
        FRAME_SET_SIZE  = method FRAME "setSize" [`int, `int]
        FRAME_SHOW      = method FRAME "show" []
        FRAME_DISPOSE   = method FRAME "dispose" []

        n        = length points
        (xs, ys) = unzip points
        zs       = map ((+ snd plotWindowSize) . negate) ys
        
        canvas   = new FUNCTION_CANVAS [paintPlot (take n xs) (take n zs) n]
        oldFrame = get window
        frame    = new FRAME ["Vitry"]
        
        do  FRAME_ADD frame canvas
            FRAME_SET_SIZE frame
                INT_PRIM (fst plotWindowSize + fst plotWindowPadding)
                INT_PRIM (snd plotWindowSize + snd plotWindowPadding)
            if  (oldFrame != nil)
                FRAME_DISPOSE oldFrame
                nil
            FRAME_SHOW frame
            set frame window
            nil

paintPlot xs ys n g =
    let GRAPHICS      = class "java.awt.Graphics"
        DRAW_POLYLINE = method GRAPHICS "drawPolyline" [class "[I", class "[I", class "int"]
        DRAW_POLYLINE g
            iarray xs
            iarray ys
            INT_PRIM n


; Output

fmsFile = fileDir ++ fileName ++ ".fms"
xmlFile = fileDir ++ fileName ++ ".xml"
lyFile  = fileDir ++ fileName ++ ".ly"


; Writes the given text to a file and displays it

export text = do
    writeFile fmsFile text
    if preview
        do run [ "fomus", fmsFile, "-o", lyFile ]
        do run [ "fomus", fmsFile, "-o", xmlFile ]
            if fixClefs
                do  print "adjusting fomus clefs..."
                    replaceFile xmlFile
                        [ "<sign>F</sign>", "<sign>C</sign>" ]
                        [ "<sign>F</sign><line>4</line>", "<sign>C</sign><line>3</line>" ]
                nil
            ; Open the score
            run [ "open", "-a", scoreEditor, xmlFile ]


; =============================================================================
; Orchestration engine

; An orchestration is a list of parts, along with two functions
; to indicate its appropriateness for some frame, and a function
; to perform the orchestration.
;   - The predicate states an absolute condition for the
;     orchestration to be used, such as pitch range.
;   - The weigher states a relative appropriateness of the
;     orchestration based on its quality. A higher weighting
;     means that the orchestration is more likely to be chosen.
;   - The orchestrator performs the orchestration.

; A frame can be anything that implements the following function 
; getFrameDur : frame -> dur

; FIXME we can not represent function types yet
; predicate    : frame -> boolean
; weighter     : frame -> double
; orchestrator : state -> frame -> (state, music)
predicate      = _
weighter       = _
orchestrator   = _
orchOptionType = `padding
orchOption     = (orchOptionType, (str | num | [str] | [num]))
orchestration  = ([part], predicate, weighter, orchestrator, [orchOption])
usage          = (dur, [part])
getUsageDur    = fst
getUsagePart   = snd

getParts          (r, p, w, o, t) = r
getPredicate      (r, p, w, o, t) = p
getWeighter       (r, p, w, o, t) = w
getOrchestrator   (r, p, w, o, t) = o
getOptions        (r, p, w, o, t) = t
setParts        r (_, p, w, o, t) = (r, p, w, o, t)
withParts f x = setParts (f (getParts x)) x


; [layer] -> [orchestration] -> music
orchestrate layers orchs =
    let offsets = take (length layers) (loop 0)
        delay orchestrate_ 0 offsets [] layers orchs

; [time] -> [usage] -> [layer] -> [orchestration] -> music
orchestrate_ lastOffset : prec offsets : [time] usage : [usage] layers orchs =
    match offsets
        _ : [] = []

        _      = do  t = minimum offsets
                     i = findIndex (== t) offsets
                     match (index i layers)
                         _ : []  = do  offsets = remove i offsets
                                       usage   = remove i usage
                                       layers  = remove i layers
                                       orchestrate_ t offsets usage layers orchs
                         (f, fs) = do  offsets = updateOffsets t i (getFrameDur f) offsets
                                       usage   = updateUsage   (t - lastOffset) usage
                                       layers  = updateLayers  i fs layers

                                       let (usage, music) = orchestrateFrame usage f orchs
                                           offsetMusic t music ++ (delay orchestrate_ t offsets usage layers orchs)

; [usage] -> frame -> [orchestration] -> ([usage], music)

orchestrateFrame usage : [usage] frame : frame orchs : [orchestration] =
    let filterIllegal = filter (somePartBusy usage)
                      . retain (acceptsFrame frame)

        orchs         = filterIllegal orchs

        match orchs
            _ : [] = do  warnNoOrchs ()
                         (usage, [])
            _      = do  weights = map   (weightFrame frame) orchs
                         i       = maximumWeight weights
                         orch    = index i orchs

                         if (matches `orchestration verbose) then (printOrchs orchs weights i) else nil

                         music = (getOrchestrator orch) frame
                         parts  = getParts orch
                         dur = match ((lookup `padding . getOptions) orch)
                             p : prec = getFrameDur frame + p
                             _        = getFrameDur frame
                         usage = prepend (dur, parts) usage
                         (usage, music)
                               
updateOffsets t i d xs   = update i (index i xs + d) xs
updateUsage   t          = filter (fn (x) getUsageDur x <= 0) . map (fn (x) (getUsageDur x - t, getUsagePart x))
updateLayers  i fs       = update i fs

acceptsFrame frame       = (flip apply) frame . getPredicate
weightFrame frame        = (flip apply) frame . getWeighter
somePartBusy usage       = any (elementOf (concat (map getUsagePart usage))) . getParts
maximumWeight            = if (matches `orchestration nonDeterministic) then anyMaximumIndex else maximumIndex
warnNoOrchs _            = do  print "warning: no orchestration"
                               nil
printOrchs orchs weights i = do  names = map (map getName) (map getParts orchs)
                                 print $ "orchs  :\n    " ++ (join "\n    " $ zip names (map (truncate 3) weights))
                                 ; print $ "  chosen: "  ++ string $ index i


; [part] -> music -> music
toParts parts music      = concat $ map (fn (p) toPart p music) parts
; part -> [voice] -> music -> music
toPartVoice part voice   = toVoice voice . toPart part
; [part] -> [voice] -> music -> music
toPartsVoice parts voice = toVoice voice . toParts parts

weightNone = const 0.5



; =============================================================================
; Main data

info   : [setting] = [ ("title",  "Skikt")            
                     , ("author", "Hans Hoglund 2011")
                     , ("clip",   [0, 0]) ]

header : [mark]    = [ ("tempo", "*1/4* = #", 90) ]
insts  : [inst]    = [ ("perc1", "percussion", [ "snare-drum", "bass-drum"
                                               , "crash-cymbal", "splash-cymbal" ]) ]

fl   : part = ("fl",   "flute",          [ ("abbr", "Fl.") ])
ob   : part = ("ob",   "oboe",           [ ("abbr", "Ob.") ])
cl   : part = ("cl",   "bflat-clarinet", [ ("abbr", "Kl.") ])
bsn  : part = ("bsn",  "bassoon",        [ ("abbr", "Fag.") ])
hrn  : part = ("hrn",  "horn",           [ ("abbr", "Hrn."), ("name", "Horn in F") ])
tpt  : part = ("tpt",  "bflat-trumpet",  [ ("abbr", "Tpt.") ])
tbn  : part = ("tbn",  "tenor-trombone", [ ("abbr", "Tbn.") ])
pno  : part = ("pno",  "piano",          [ ("abbr", "Pno.") ])
pno2 : part = ("pno2", "piano",          [ ("abbr", "Pno. II") ])
vib  : part = ("vib",  "vibraphone",     [ ("abbr", "Vib.") ])
crot : part = ("crot", "vibraphone",     [ ("abbr", "Crot."), ("name", "Crotales") ])
prc  : part = ("perc", "perc1",          [ ("abbr", "Perc."), ("name", "Percussion") ])
vl1  : part = ("vl1",  "violin",         [ ("abbr", "Vl. I") ])
vl2  : part = ("vl2",  "violin",         [ ("abbr", "Vl. II") ])
vla  : part = ("vla",  "viola",          [ ("abbr", "Vla.") ])
vc   : part = ("vc",   "cello",          [ ("abbr", "Vc."), ("name", "Violoncello") ])
db   : part = ("db",   "bass",           [ ("abbr", "Kb.") ])



parts : [part] = [ fl, ob, cl, bsn, hrn, tpt, tbn, pno, pno2, vib, crot, prc, vl1, vl2, vla, vc, db ]
decls : [decl] = insts ++ parts

percNote inst = match inst
    x : `bassDrum    = 65
    x : `snareDrum   = 72
    x : `smallCymbal = 76
    x : `largeCymbal = 79


; Layer definitions

dynamic    = double
density    = double
saturation = double
resonance  = double

frame = (dur, [dur], [pitch], dynamic, density, saturation, resonance)
layer = [frame]

getFrameDur        (d, _,  _,  _, _, _, _) = d
getFrameDurs       (_, ds, _,  _, _, _, _) = ds
getFramePitches    (_, _,  ps, _, _, _, _) = ps
getFrameDynamic    (_, _,  _,  n, _, _, _) = n
getFrameDensity    (_, _,  _,  _, t, _, _) = t
getFrameSaturation (_, _,  _,  _, _, s, _) = s
getFrameResonance  (_, _,  _,  _, _, _, r) = r
weightAll       f  (_, _, _, n, t, s, r)   = f n t s r
weightDynDen    f  (_, _, _, n, t, s, r)   = f n t
weightDynSat    f  (_, _, _, n, t, s, r)   = f n s
weightDynRes    f  (_, _, _, n, t, s, r)   = f n r
weightDenSat    f  (_, _, _, n, t, s, r)   = f t s
weightDenRes    f  (_, _, _, n, t, s, r)   = f t r
weightSatRes    f  (_, _, _, n, t, s, r)   = f s r
weightDyn       f  (_, _, _, n, t, s, r)   = f n
weightDen       f  (_, _, _, n, t, s, r)   = f t
weightSat       f  (_, _, _, n, t, s, r)   = f s
weightRes       f  (_, _, _, n, t, s, r)   = f r

; layer -> dur
getLayerDur = sum . map getFrameDur

weight2 = splitWith mean2
weight3 = splitWith3 mean3


; Predicates, weightings & orchestrations

; frame -> bool
minDyn      = (flip (>=) minDynLevel) . getFrameDynamic

; range -> frame -> bool
durRange   r = all (inRange r) . getFrameDurs
pitchRange r = all (inRange r) . getFramePitches

pitchDurRange       ps ds = splitWith (&&) (pitchRange ps) (durRange ds)
durRangeMinDyn      ds    = splitWith (&&) (durRange ds) minDyn
pitchRangeMinDyn    ps    = splitWith (&&) (pitchRange ps) minDyn
pitchDurRangeMinDyn ps ds = splitWith (&&) (pitchDurRange ps ds) minDyn

; ([dur] -> [pitch]) -> frame -> music
lineOrch     f   (_, ds, ps, n, _, _, _) = mapMusic (setDyn n) $ f ds ps
; (dur -> [pitch]) -> frame -> music
harmOrch     f   (d, ds, ps, n, _, _, _) = mapMusic (setDyn n) $ f ds (loop ps)
longHarmOrch f   (d, _,  ps, n, _, _, _) = mapMusic (setDyn n) $ f d ps
percOrch     f i (d, ds, _,  n, _, _, _) = mapMusic (setDyn n) $ f ds (loop $ percNote i) 

; music -> music
artHarm music = map (addMark "artharm-sounding") music
             ++ map (withPitch (+ (-19)) . addMark "artharm-touched") music
             ++ map (withPitch (+ (-24)) . addMark "artharm-base"   ) music            

toPart  part  = mapMusic (setPart part)
toVoice voice = mapMusic (setVoice voice)



; Layer data 


curve1  = curve 700  $ map (* 1.5) . sinG . mulG (line 4700) . sinG
curve2  = curve 700  $ map (* negate 1.5) . sinG . mulG (line 4700) . sinG
curve3  = reverse curve1
curve4  = reverse curve2

curve5  = curve 700 $ sinG . map ((+ 0.75) . (* 0.5))
curve6  = curve 700 $ sinG . map ((+ 0.0)  . (* 0.5))
curve7  = curve 700 $ sinG . map ((+ 0.25) . (* 0.5))
curve8  = curve 700 $ sinG . map ((+ 0.5)  . (* 0.5))

curve9  = curve 700 $ sinG . map ((+ 0.75)  . (* 0.8))
curve10 = curve 700 $ sinG . map ((+ 0.0)  . (* 0.8))
curve11 = curve 700 $ sinG . map ((+ 0.25) . (* 0.8))
curve12 = curve 700 $ sinG . map ((+ 0.5)  . (* 0.8))

mode1 = map (+ 48) $ [ 0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23, 24, 26, 28, 29, 31, 33, 35, 36 ]
mode2 = map (+ 49) $ [ 0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23, 24, 26, 28, 29, 31, 33, 35, 36 ]


scaledMode1 = zipWith (retainScaledRange (48, 84)) (zip (sample 300 curve8) (sample 300 curve6)) (loop mode1) 
scaledMode2 = zipWith (retainScaledRange (48, 84)) (zip (sample 280 curve8) (sample 280 curve6)) (loop mode2) 
scaledMode3 = zipWith (retainScaledRange (48, 84)) (zip (sample 140 curve8) (sample 140 curve6)) (loop mode1) 
scaledMode4 = zipWith (retainScaledRange (48, 84)) (zip (sample 140 curve8) (sample 140 curve6)) (loop mode2) 


short1 =
    zip7
        map  ((* 1/3) . (+ 11) . round . (* 11.0)) $ (sample 300 curve5)
        loop [(1/3)]                          
        map single $ map pick (map (prepend 60) scaledMode1) 

        sample 300 curve1
        sample 300 curve2
        sample 300 curve12
        loop 0.1
               
short2 =
    zip7
        map  ((* 2/5) . (+ 11) . round . (* 11.0)) $ (sample 280 curve7)
        loop [(1/3)]                          
        map single $ map pick (map (prepend 60) scaledMode2) 

        map (* 0.6) $ sample 280 curve4
        sample 280 curve7
        sample 280 curve1
        loop 0.1
                 
resonant1 =
    zip7
        map (* (6/2)) $ map (+ 1) (rands 5)
        loop []
        map tessitura $ scaledMode3 
        
        map (* 0.8) $ sample 70 curve7
        sample 140 curve6
        sample 140 curve4
        loop 1.0
        
resonant2 =
    zip7              
        map (* (7/3) + 1) $ map (+ 1) (rands 3)
        loop []
        map tessitura $ scaledMode4

        map (* 0.8) $ sample 70 curve8
        sample 140 curve2
        sample 140 curve3
        loop 1.0
                                  
dummy1 = (400, [1], [60], 0.0, 0.0, 0.0, 0.0)
dummy2 = (700, [1], [60], 0.0, 0.0, 0.0, 0.0)
layers = [short1, short2, prepend dummy1 resonant1, prepend dummy2 resonant2]





; Orchestrations

orchestrations = 

    [ ( [fl]
        , pitchRangeMinDyn (60, 93)
        , weight3 (weightDyn $ gaussian 0.4 30.0) (weightDen $ gaussian 0.6 35.0) (weightSat $ gaussian 0.4 25.0) 
        , toParts [fl]  . lineOrch melody, [] )
    , ( [ob]
        , pitchRangeMinDyn (62, 88)
        , weight3 (weightDyn $ gaussian 0.4 30.0) (weightDen $ gaussian 0.6 35.0) (weightSat $ gaussian 0.5 25.0)
        , toParts [ob]  . lineOrch melody, [] )
    , ( [cl]
        , pitchRangeMinDyn (50, 86)
        , weight3 (weightDyn $ gaussian 0.4 30.0) (weightDen $ gaussian 0.6 35.0) (weightSat $ gaussian 0.45 25.0)
        , toParts [cl]  . lineOrch melody, [] )
    , ( [bsn]
        , pitchRangeMinDyn (34, 58)
        , weight3 (weightDyn $ gaussian 0.4 30.0) (weightDen $ gaussian 0.6 35.0) (weightSat $ gaussian 0.5 25.0)
        , toParts [bsn] . lineOrch melody, [] )   
    , ( [fl]         
        , pitchDurRangeMinDyn (60, 93) (0, 1)
        , weight3 (weightDyn $ gaussian 0.4 30.0) (weightDen $ gaussian 0.2 35.0) (weightSat $ gaussian 0.4 25.0)
        , toParts [fl]  . lineOrch staccato, [] )
    , ( [ob]
        , pitchDurRangeMinDyn (62, 88) (0, 1)
        , weight3 (weightDyn $ gaussian 0.4 30.0) (weightDen $ gaussian 0.2 35.0) (weightSat $ gaussian 0.5 25.0)
        , toParts [ob]  . lineOrch staccato, [] )
    , ( [cl]
        , pitchDurRangeMinDyn (50, 86) (0, 1)
        , weight3 (weightDyn $ gaussian 0.4 30.0) (weightDen $ gaussian 0.2 35.0) (weightSat $ gaussian 0.45 25.0)
        , toParts [cl]  . lineOrch staccato, [] )
    , ( [bsn], pitchDurRangeMinDyn (34, 58) (0, 1)
        , weight3 (weightDyn $ gaussian 0.4 30.0) (weightDen $ gaussian 0.2 35.0) (weightSat $ gaussian 0.5 25.0)
        , toParts [bsn] . lineOrch staccato, [] )                                                                                        
    
    
    , ( [hrn]
        , pitchRangeMinDyn (48, 71)
        , weight3 (weightDyn $ gaussian 0.85 30.0) (weightDen $ gaussian 0.6 35.0) (weightSat $ gaussian 0.4 25.0) 
        , toParts [hrn] . lineOrch melody, [] )
    , ( [tpt]
        , pitchRangeMinDyn (53, 81)
        , weight3 (weightDyn $ gaussian 0.95 30.0) (weightDen $ gaussian 0.6 35.0) (weightSat $ gaussian 0.4 25.0) 
        , toParts [tpt] . lineOrch melody, [] )
    , ( [tbn]
        , pitchRangeMinDyn (40, 58)
        , weight3 (weightDyn $ gaussian 0.95 30.0) (weightDen $ gaussian 0.6 35.0) (weightSat $ gaussian 0.4 25.0) 
        , toParts [tbn] . lineOrch melody, [] )
    , ( [hrn]
        , pitchDurRangeMinDyn (48, 71) (0, 1)
        , weight3 (weightDyn $ gaussian 0.85 30.0) (weightDen $ gaussian 0.2 35.0) (weightSat $ gaussian 0.4 25.0) 
        , toParts [hrn] . lineOrch staccato, [] )
    , ( [tpt]
        , pitchDurRangeMinDyn (53, 81) (0, 1)
        , weight3 (weightDyn $ gaussian 0.95 30.0) (weightDen $ gaussian 0.2 35.0) (weightSat $ gaussian 0.4 25.0) 
        , toParts [tpt] . lineOrch staccato, [] )
    , ( [tbn]
        , pitchDurRangeMinDyn (40, 69) (0, 1)
        , weight3 (weightDyn $ gaussian 0.95 30.0) (weightDen $ gaussian 0.2 35.0) (weightSat $ gaussian 0.4 25.0) 
        , toParts [tbn] . lineOrch staccato, [] )  
    , ( [hrn]
        , pitchRangeMinDyn (48, 71)
        , weight3 (weightDyn $ gaussian 0.7 30.0) (weightDen $ gaussian 0.6 35.0) (weightSat $ gaussian 0.7 25.0) 
        , toParts [hrn] . (map (addMark "mute") . lineOrch melody), [] )
    , ( [tpt]
        , pitchRangeMinDyn (53, 81)
        , weight3 (weightDyn $ gaussian 0.7 30.0) (weightDen $ gaussian 0.6 35.0) (weightSat $ gaussian 0.7 25.0) 
        , toParts [tpt] . (map (addMark "mute") . lineOrch melody), [] )
    , ( [tbn]
        , pitchRangeMinDyn (40, 58)
        , weight3 (weightDyn $ gaussian 0.7 30.0) (weightDen $ gaussian 0.6 35.0) (weightSat $ gaussian 0.7 25.0) 
        , toParts [tbn] . (map (addMark "mute") . lineOrch melody), [] )
    , ( [hrn]
        , pitchDurRangeMinDyn (48, 71) (0, 1)
        , weight3 (weightDyn $ gaussian 0.7 30.0) (weightDen $ gaussian 0.2 35.0) (weightSat $ gaussian 0.7 25.0) 
        , toParts [hrn] . (map (addMark "mute") . lineOrch staccato), [] )
    , ( [tpt]
        , pitchDurRangeMinDyn (53, 81) (0, 1)
        , weight3 (weightDyn $ gaussian 0.7 30.0) (weightDen $ gaussian 0.2 35.0) (weightSat $ gaussian 0.7 25.0) 
        , toParts [tpt] . (map (addMark "mute") . lineOrch staccato), [] )
    , ( [tbn]
        , pitchDurRangeMinDyn (40, 58) (0, 1)
        , weight3 (weightDyn $ gaussian 0.7 30.0) (weightDen $ gaussian 0.2 35.0) (weightSat $ gaussian 0.7 25.0) 
        , toParts [tbn] . (map (addMark "mute") . lineOrch staccato), [] )
                                                                                                    
    
    
    , ( [prc]
        , durRangeMinDyn (0, 1)
        , weight3 (weightDyn $ (* 0.5) . gaussian 0.6 30.0) (weightDen $ gaussian 0.1 35.0) (weightSat $ gaussian 0.9 25.0) 
        , toParts [prc]  . percOrch melody `bassDrum, [] )
    , ( [prc]
        , durRangeMinDyn (0, 1)
        , weight3 (weightDyn $ (* 0.5) . gaussian 0.6 30.0) (weightDen $ gaussian 0.1 35.0) (weightSat $ gaussian 0.9 25.0) 
        , toParts [prc]  . percOrch melody `snareDrum, [] )
    , ( [prc]
        , durRangeMinDyn (1, 2 ^ 12)
        , weight3 (weightDyn $ (* 0.5) . gaussian 0.6 30.0) (weightDen $ gaussian 0.1 35.0) (weightSat $ gaussian 0.9 25.0) 
        , toParts [prc]  . percOrch melody `smallCymbal, [] )
    , ( [prc]
        , durRangeMinDyn (1, 2 ^ 12)
        , weight3 (weightDyn $ (* 0.5) . gaussian 0.6 30.0) (weightDen $ gaussian 0.1 35.0) (weightSat $ gaussian 0.9 25.0) 
        , toParts [prc]  . percOrch melody `largeCymbal, [] )
    , ( [prc]
        , durRangeMinDyn (2, 2 ^ 12)
        , weight3 (weightDyn $ (* 0.5) . gaussian 0.8 30.0) (weightDen $ gaussian 0.5 35.0) (weightSat $ gaussian 0.9 25.0) 
        , toParts [prc]  . (map (addMark "trem") . percOrch melody `bassDrum), [] )
    , ( [prc]
        , durRangeMinDyn (2, 2 ^ 12)
        , weight3 (weightDyn $ (* 0.5) . gaussian 0.8 30.0) (weightDen $ gaussian 0.5 35.0) (weightSat $ gaussian 0.9 25.0) 
        , toParts [prc] . (map (addMark "trem") . percOrch melody `snareDrum), [] )
    , ( [prc]
        , durRangeMinDyn (2, 2 ^ 12)
        , weight3 (weightDyn $ (* 0.5) . gaussian 0.8 30.0) (weightDen $ gaussian 0.5 35.0) (weightSat $ gaussian 0.9 25.0) 
        , toParts [prc]  . (map (addMark "trem") . percOrch melody `smallCymbal), [] )
    , ( [prc]
        , durRangeMinDyn (2, 2 ^ 12)
        , weight3 (weightDyn $ (* 0.5) . gaussian 0.8 30.0) (weightDen $ gaussian 0.5 35.0) (weightSat $ gaussian 0.9 25.0) 
        , toParts [prc]  . (map (addMark "trem") . percOrch melody `largeCymbal), [] )
                                                                                                    
    
    
    , ( [pno]
        , pitchRangeMinDyn (21, 108)
        ; , weightSatRes (fn (sat res) mean2 (gaussian 0.4 30.0 sat) (gaussian 1.0 100.0 res))
        , weightSatRes (fn (sat res) (gaussian 1.0 100.0 res))
        , toParts [pno]  . longHarmOrch chord, [] )
    , ( [pno2]
        , pitchRangeMinDyn (21, 108)
        ; , weightSatRes (fn (sat res) mean2 (gaussian 0.4 30.0 sat) (gaussian 1.0 100.0 res))
        , weightSatRes (fn (sat res) (gaussian 1.0 100.0 res))
        , toParts [pno2]  . longHarmOrch chord, [] )

    , ( [crot, vib]
        , pitchRangeMinDyn (84, 96)
        ; , weightSatRes (fn (sat res) mean2 (gaussian 0.7 30.0 sat) (gaussian 1.0 100.0 res))
        , weightSatRes (fn (sat res) (gaussian 1.0 100.0 res))
        , toPartsVoice [crot] (1 .. 4) . longHarmOrch chord, [] )
    , ( [crot, vib]
        , pitchRangeMinDyn (53, 89)
        ; , weightSatRes (fn (sat res) mean2 (gaussian 0.6 30.0 sat) (gaussian 1.0 100.0 res))
        , weightSatRes (fn (sat res) (gaussian 1.0 100.0 res))
        , toPartsVoice [vib] (1 .. 4)  . longHarmOrch chord, [] )
                                                                                                    
    
    
    ; , ( [vl1]
    ;     , pitchRangeMinDyn (55, 91)
    ;     , weightNone
    ;     , toParts [vl1] . lineOrch melody, [] )
    ; , ( [vl2]
    ;     , pitchRangeMinDyn (55, 91)
    ;     , weightNone
    ;     , toParts [vl2] . lineOrch melody, [] )
    ; , ( [vla]
    ;     , pitchRangeMinDyn (48, 84)
    ;     , weightNone
    ;     , toParts [vla] . lineOrch melody, [] )
    ; , ( [vc]
    ;     , pitchRangeMinDyn (36, 72)
    ;     , weightNone
    ;     , toParts [vc]  . lineOrch melody, [] )
    ; , ( [db]
    ;     , pitchRangeMinDyn (28, 52)
    ;     , weightNone
    ;     , toParts [db]  . lineOrch melody, [] )
    ; 
    ; , ( [vl1]
    ;     , pitchRangeMinDyn (55, 91)
    ;     , weightNone
    ;     , toParts [vl1] . lineOrch tenuto, [] )
    ; , ( [vl2]
    ;     , pitchRangeMinDyn (55, 91)
    ;     , weightNone
    ;     , toParts [vl2] . lineOrch tenuto, [] )
    ; , ( [vla]
    ;     , pitchRangeMinDyn (48, 84)
    ;     , weightNone
    ;     , toParts [vla] . lineOrch tenuto, [] )
    ; , ( [vc]
    ;     , pitchRangeMinDyn (36, 72)
    ;     , weightNone
    ;     , toParts [vc]  . lineOrch tenuto, [] )
    ; , ( [db]
    ;     , pitchRangeMinDyn (28, 52)
    ;     , weightNone
    ;     , toParts [db]  . lineOrch tenuto, [] )
    ; 
    ; , ( [vl1], pitchDurRangeMinDyn (55, 91) (0, 2)
    ;     , weightNone
    ;     , toParts [vl1] . lineOrch staccato, [] )
    ; , ( [vl2], pitchDurRangeMinDyn (55, 91) (0, 2)
    ;     , weightNone
    ;     , toParts [vl2] . lineOrch staccato, [] )
    ; , ( [vla], pitchDurRangeMinDyn (48, 84) (0, 2)
    ;     , weightNone
    ;     , toParts [vla] . lineOrch staccato, [] )
    ; , ( [vc], pitchDurRangeMinDyn (36, 72) (0, 2)
    ;     , weightNone
    ;     , toParts [vc]  . lineOrch staccato, [] )
    ; , ( [db], pitchDurRangeMinDyn (28, 52) (0, 2)
    ;     , weightNone
    ;     , toParts [db]  . lineOrch staccato, [] )
    
    , ( [vl1]                                    
        , pitchDurRangeMinDyn (55, 91) (0, 1+1/2)
        , weight3 (weightDyn $ gaussian 0.38 30.0) (weightDen $ gaussian 0.1 35.0) (weightSat $ gaussian 0.6 25.0) 
        , toParts [vl1] . lineOrch pizz, [] )
    , ( [vl2]
        , pitchDurRangeMinDyn (55, 91) (0, 1+1/2)
        , weight3 (weightDyn $ gaussian 0.38 30.0) (weightDen $ gaussian 0.1 35.0) (weightSat $ gaussian 0.6 25.0) 
        , toParts [vl2] . lineOrch pizz, [] )
    , ( [vla]
        , pitchDurRangeMinDyn (48, 84) (0, 1+1/2)
        , weight3 (weightDyn $ gaussian 0.38 30.0) (weightDen $ gaussian 0.1 35.0) (weightSat $ gaussian 0.6 25.0) 
        , toParts [vla] . lineOrch pizz, [] )
    , ( [vc]
        , pitchDurRangeMinDyn (36, 72) (0, 1+1/2)
        , weight3 (weightDyn $ gaussian 0.4 30.0) (weightDen $ gaussian 0.1 35.0) (weightSat $ gaussian 0.6 25.0) 
        , toParts [vc]  . lineOrch pizz, [] )
    , ( [db]
        , pitchDurRangeMinDyn (28, 52) (0, 1+1/2)
        , weight3 (weightDyn $ gaussian 0.4 30.0) (weightDen $ gaussian 0.1 35.0) (weightSat $ gaussian 0.5 25.0) 
        , toParts [db]  . lineOrch pizz, [] ) ]
    
    ; , ( [vl1]
    ;     , pitchDurRangeMinDyn (79, 99) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [vl1] . (artHarm . lineOrch melody), [] )
    ; , ( [vl2]
    ;     , pitchDurRangeMinDyn (79, 99) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [vl2] . (artHarm . lineOrch melody), [] )
    ; , ( [vla]
    ;     , pitchDurRangeMinDyn (72, 90) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [vla] . (artHarm . lineOrch melody), [] )
    ; , ( [vc]
    ;     , pitchDurRangeMinDyn (60, 80) (0, 1)
    ;     , weightSat (* 0.6)
    ;     , toParts [vc]  . (artHarm . lineOrch melody), [] )
    ; , ( [db]
    ;     , pitchDurRangeMinDyn (52, 60) (0, 1)
    ;     , weightSat (* 0.6)
    ;     , toParts [db]  . (artHarm . lineOrch melody), [] )
    ; 
    ; , ( [vl1]
    ;     , pitchDurRangeMinDyn (79, 99) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [vl1] . (artHarm . lineOrch melody), [] )
    ; , ( [vl2]
    ;     , pitchDurRangeMinDyn (79, 99) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [vl2] . (artHarm . lineOrch melody), [] )
    ; , ( [vla]
    ;     , pitchDurRangeMinDyn (72, 90) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [vla] . (artHarm . lineOrch melody), [] )
    ; , ( [vc]
    ;     , pitchDurRangeMinDyn (60, 80) (0, 1)
    ;     , weightSat (* 0.6)
    ;     , toParts [vc]  . (artHarm . lineOrch melody), [] )
    ; , ( [db]
    ;     , pitchDurRangeMinDyn (52, 60) (0, 1)
    ;     , weightSat (* 0.6)
    ;     , toParts [db]  . (artHarm . lineOrch melody), [] )
    ; 
    ; , ( [vl1]
    ;     , pitchDurRangeMinDyn (79, 99) (0, 8)
    ;     , weightSat (* 0.8)
    ;     , toParts [vl1] . (artHarm . lineOrch pizz), [] )
    ; , ( [vl2]
    ;     , pitchDurRangeMinDyn (79, 99) (0, 8)
    ;     , weightSat (* 0.8)
    ;     , toParts [vl2] . (artHarm . lineOrch pizz), [] )
    ; , ( [vla]
    ;     , pitchDurRangeMinDyn (72, 90) (0, 8)
    ;     , weightSat (* 0.8)
    ;     , toParts [vla] . (artHarm . lineOrch pizz), [] )
    ; , ( [vc]
    ;     , pitchDurRangeMinDyn (60, 80) (0, 8)
    ;     , weightSat (* 0.6)
    ;     , toParts [vc]  . (artHarm . lineOrch pizz), [] )
    ; , ( [db]
    ;     , pitchDurRangeMinDyn (52, 60) (0, 8)
    ;     , weightSat (* 0.6)
    ;     , toParts [db]  . (artHarm . lineOrch pizz), [] )   
    
    ; , ( [vl1]
    ;     , pitchDurRangeMinDyn (55, 91) (1, 2^12)
    ;     , weightSat (* 0.8)
    ;     , toParts [vl1] . (map (addMark "trem") . lineOrch melody), [] )
    ; , ( [vl2]
    ;     , pitchDurRangeMinDyn (55, 91) (1, 2^12)
    ;     , weightSat (* 0.8)
    ;     , toParts [vl2] . (map (addMark "trem") . lineOrch melody), [] )
    ; , ( [vla]
    ;     , pitchDurRangeMinDyn (48, 84) (1, 2^12)
    ;     , weightSat (* 0.8)
    ;     , toParts [vla] . (map (addMark "trem") . lineOrch melody), [] )
    ; , ( [vc]
    ;     , pitchDurRangeMinDyn (36, 72) (1, 2^12)
    ;     , weightSat (* 0.8)
    ;     , toParts [vc]  . (map (addMark "trem") . lineOrch melody), [] )
    ; , ( [db]
    ;     , pitchDurRangeMinDyn (28, 52) (1, 2^12)
    ;     , weightSat (* 0.8)
    ;     , toParts [db]  . (map (addMark "trem") . lineOrch melody), [] ) ]
    ;        
    ; , ( [vl1]
    ;     , pitchDurRangeMinDyn (79, 99) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [vl1] . (artHarm . map (addMark "trem") . lineOrch melody), [] )
    ; , ( [vl2]
    ;     , pitchDurRangeMinDyn (79, 99) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [vl2] . (artHarm . map (addMark "trem") . lineOrch melody), [] )
    ; , ( [vla]
    ;     , pitchDurRangeMinDyn (72, 90) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [vla] . (artHarm . map (addMark "trem") . lineOrch melody), [] )
    ; , ( [vc]
    ;     , pitchDurRangeMinDyn (60, 80) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [vc]  . (artHarm . map (addMark "trem") . lineOrch melody), [] )
    ; , ( [db]
    ;     , pitchDurRangeMinDyn (52, 60) (0, 1)
    ;     , weightSat (* 0.8)
    ;     , toParts [db]  . (artHarm . map (addMark "trem") . lineOrch melody), [] ) ] 






; =============================================================================
; Main program

help _      = do  print "Skikt"
                  print "   use: help (), main (), test ()"
                  nil
events      = ref (delay orchestrate layers orchestrations)
main _      = (export . fomus) (get events, decls, info)
test _      = fomus (get events, decls, info)

dump x      = match x
    _ : events = join "\n" (get events)
    _          = join "\n" x
