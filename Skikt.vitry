; load "~/Documents/Musik/Skikt/Skikt.vitry"

; =============================================================================
; Skikt
; Hans Hoglund (2011)
; Vitry v0.1.x
; =============================================================================

module Hans.Music.Skikt

SCORE_EDITOR  = "/Applications/Sibelius 6.app"
FILE_LOCATION = "/Users/hans/Documents/Musik/Skikt/output/"
FILE_NAME     = "out"

; =============================================================================






header = "title Skikt"

instruments = join "\n"
            [ "part <id fl,   abbr Fl,        inst flute>"
            , "part <id ob,   abbr Ob,        inst oboe>"
            , "part <id cl,   abbr Kl,        inst bflat-clarinet>"
            , "part <id bsn,  abbr Fag,       inst bassoon>"

            , "part <id hrn,  abbr Hrn,       inst horn>"
            , "part <id tpt,  abbr Tpt,       inst bflat-trumpet>"
            , "part <id tbn,  abbr Tbn,       inst tenor-trombone>"

            , "part <id pno,  abbr Pno,       inst piano>"

            , "part <id vb,   abbr Vib,       inst vibraphone>"
            , "part <id crot, abbr Crot,      inst vibraphone, name Crotales>"
            , "inst <id perc1, template percussion, percinsts (snare-drum bass-drum)>"
            , "part <id perc, abbr Perc       inst perc1>"

            , "part <id vl1,  abbr \"Vl I\",  inst violin>"
            , "part <id vl2,  abbr \"Vl II\", inst violin>"
            , "part <id vla,  abbr Vla,       inst viola>"
            , "part <id vc,   abbr Vc,        inst cello, name Violoncello>"
            , "part <id db,   abbr Kb,        inst bass>" ]



tptPart =   join "\n" [ "time + dur 8/5 pitch 60;"
            , "time + pitch 67 [>] [.];"
            , "time + pitch 62 [!];"
            , "time + pitch 58 [sfz];" ]


events =  "\n"
       ++ "part tpt\n"
       ++ tptPart
       ++ "\n"
       ++ "part db clef bass\n"
       ++ "time + pitch 38[>];"

events2 = join "\n" (take 15 (loop events))

output = header ++ "\n\n" ++ instruments ++ "\n\n" ++ events2















; ============================================================
; FOMUS

; Interface to the FOMUS notation engine by David Psenicka
; See http://fomus.sourceforge.net/

; The workflow is to create a data structure representing a score
; and pass it to the fomus function. This function generates a
; text on a format understood by FOMUS, which may be written to
; a fms file.


time    = prec
dur     = prec
grace   = prec
pitch   = prec
part    = int
voice   = int
dynamic = float


; Mapping from string to value
; May be included in most definitions

setting = (str, (str | num | [str] | [num]))

; Marks can be represented by a single string (same as in FOMUS files)
; or as a tuple, containing arguments. We define some common cases as
; symbols as well.

; For a througout description, see the FOMUS documentation

markId  = "(.." | "*" | "+" | "-" | "."
        | ".((." | ".(." | "..)" | "..))"
        | "..<" | "..>" | "."
        | "dash)" | "..dash))"
        | "..dot)" | "..dot))"
        | "..grace)"
        | "..ped"
        | "..tup"
        | "..x!" | "..x^" | "..x_" | ".<." | ".>."
        | ".dash((." | ".dash(."
        | ".dot((." | ".dot(."
        | ".grace(."
        | ".ped."
        | ".x!." | ".x^." | ".x_."
        | "/" | "/."
        | "0"
        | "<.." | ">" | ">.."
        | "^"
        | "arco" | "arp" | "arp^" | "arp_"
        | "artharm-base" | "artharm-sounding" | "artharm-touched"
        | "bellsup"
        | "break<" | "break>"
        | "breath" | "breath<" | "breath>"
        | "cuivre"
        | "damp"
        | "dash((.." | "dash(.."
        | "dot((.." | "dot(.."
        | "downbow"
        | "dyn"
        | "etouf"
        | "f"
        | "ferm" | "ferm-long" | "ferm-short" | "ferm-verylong"
        | "ff" | "fff" | "ffff" | "fffz" | "ffz"
        | "flaut"
        | "flt"
        | "fz"
        | "gliss<" | "gliss>"
        | "grace(.."
        | "leg"
        | "legno"
        | "longtr" | "longtr2"
        | "lv"
        | "mf"
        | "moltoleg" | "moltovib"
        | "mp"
        | "mute"
        | "natharm-sounding" | "natharm-string" | "natharm-touched"
        | "nonleg"
        | "nonvib"
        | "o"
        | "ord"
        | "p"
        | "ped.."
        | "pizz"
        | "pont"
        | "port<" | "port>"
        | "pp" | "ppp" | "pppp" | "ppppp" | "pppppp"
        | "punta"
        | "rf" | "rfz"
        | "ric"
        | "salt"
        | "sf" | "sff" | "sfff" | "sfffz" | "sffz" | "sfz"
        | "slap"
        | "snap" | "snappizz"
        | "spic"
        | "sul" | "table" | "tall" | "tasto"
        | "tempo"
        | "trem" | "trem2"
        | "tup.."
        | "unmute" | "upbow"
        | "vib"
        | "x" | "x!" | "x!.." | "x^" | "x^.." | "x_" | "x_.." | "~"
        | (`-) | (`.) | (`!) | (`+)
        | `f | `ff | `fff | `ffff
        | `mp | `mf
        | `p | `pp | `ppp | `pppp

mark    = markId
        | ( markId, num )
        | ( markId, str )
        | ( markId, num, str )

fff     = `fff
ff      = `ff
f       = `f
mf      = `mf
mp      = `mp
p       = `p
pp      = `pp
ppp     = `ppp

; Events are sparse structures
; TODO sticky values:
;       time, duration, pitch, part, voice, dynamic, grace

note    = ( time, dur, grace, voice, part, pitch, dynamic, [mark], [setting] )
        | ( time, dur, grace, voice, part, pitch, dynamic, [mark] )
        | ( time, dur, grace, voice, part, pitch, dynamic )
        | ( time, dur, grace, voice, part, pitch, [mark] )
        | ( time, dur, grace, voice, part, pitch )

; FOMUS creates rests implicitly, the following form is only
; useful if you want to define marks or settings apart from
; a particular note event.

rest    = ( time, dur, grace, voice, part, [mark], [setting] )
        | ( time, dur, grace, voice, part, [mark] )
        | ( time, dur, grace, voice, part, [setting] )
        | ( time, dur, grace, voice, part )

; The same goes for measures. Measdefs are just to create
; explicit downbeats/time signature changes and so on.

measdef = ( time, dur, [setting] )

event   = note | rest | measdef

; instrument = ...
; part = (instrument, [event], [setting])
; score = ([part], [setting])

; metapart = ...
; staff = ([clef], [setting])



; Returns a string representation of the given FOMUS data,
; in the FOMUS native file format.

; score -> str
fomus data = match data
    ; score =
    ; part =
    ; metapart =
    ; partmap =
    ; inst =
    ; measure
    [ _ : event ] = 1




; Output

fmsFile = FILE_LOCATION ++ FILE_NAME ++ ".fms"
xmlFile = FILE_LOCATION ++ FILE_NAME ++ ".xml"

; Writes the contents of output to a score and displays it
; () -> ()
export _ = do
    writeFile fmsFile output
    run [ "fomus", fmsFile, "-o", xmlFile ]

    ; Workaround issue with FOMUS and clefs
    print "adjusting fomus clefs..."
    replaceFile xmlFile
        [ "<sign>F</sign>", "<sign>C</sign>" ]
        [ "<sign>F</sign><line>4</line>", "<sign>C</sign><line>3</line>" ]

    run [ "open", "-a", SCORE_EDITOR, xmlFile ]
