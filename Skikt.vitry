; load "~/Documents/Musik/Skikt/Skikt.vitry"

; =============================================================================
; Skikt
; Hans Hoglund (2011)
; Vitry v0.1.x
; =============================================================================

module Hans.Music.Skikt

SCORE_EDITOR  = "/Applications/Sibelius 6.app"
FILE_LOCATION = "/Users/hans/Documents/Musik/Skikt/output/"
FILE_NAME     = "out"

; =============================================================================





info  = [ ("title", "Skikt") ]
    
parts = [ ("fl",   "flute",             [ ("abbr", "Fl") ])
        , ("ob",   "oboe",              [ ("abbr", "Ob") ])
        , ("cl",   "bflat-clarinet",    [ ("abbr", "Kl") ])
        , ("bsn",  "bassoon",           [ ("abbr", "Fag") ])
        
        , ("hrn",  "horn",              [ ("abbr", "Hrn") ])
        , ("tpt",  "bflat-trumpet",     [ ("abbr", "Tpt") ])
        , ("tbn",  "tenor-trombone",    [ ("abbr", "Tbn") ])
        , ("pno",  "piano",             [ ("abbr", "Pno") ])
        , ("vib",  "vibraphone",        [ ("abbr", "Vib") ])
        , ("crot", "vibraphone",        [ ("abbr", "Crot")
                                        , ("name", "Crotales") ])
        ; , ("perc1", [("abbr", "Fl")])
        
        , ("vl1",  "violin",            [ ("abbr", "Vl I") ])
        , ("vl2",  "violin",            [ ("abbr", "Vl II") ])
        , ("vla",  "viola",             [ ("abbr", "Vla") ])
        , ("vc",   "cello",             [ ("abbr", "Vc")
                                        , ("name", "Violoncello") ])   
        , ("db",   "bass",              [ ("abbr", "Kb") ])]



; header = "title Skikt"
;
; instruments = join "\n"
;             [ "part <id fl,   abbr Fl,        inst flute>"
;             , "part <id ob,   abbr Ob,        inst oboe>"
;             , "part <id cl,   abbr Kl,        inst bflat-clarinet>"
;             , "part <id bsn,  abbr Fag,       inst bassoon>"
; 
;             , "part <id hrn,  abbr Hrn,       inst horn>"
;             , "part <id tpt,  abbr Tpt,       inst bflat-trumpet>"
;             , "part <id tbn,  abbr Tbn,       inst tenor-trombone>"
; 
;             , "part <id pno,  abbr Pno,       inst piano>"
; 
;             , "part <id vb,   abbr Vib,       inst vibraphone>"
;             , "part <id crot, abbr Crot,      inst vibraphone, name Crotales>"
;             , "inst <id perc1, template percussion, percinsts (snare-drum bass-drum)>"
;             , "part <id perc, abbr Perc       inst perc1>"
; 
;             , "part <id vl1,  abbr \"Vl I\",  inst violin>"
;             , "part <id vl2,  abbr \"Vl II\", inst violin>"
;             , "part <id vla,  abbr Vla,       inst viola>"
;             , "part <id vc,   abbr Vc,        inst cello, name Violoncello>"
;             , "part <id db,   abbr Kb,        inst bass>" ]
; 
; 
; 
; tptPart =   join "\n" [ "time + dur 8/5 pitch 60;"
;             , "time + pitch 67 [>] [.];"
;             , "time + pitch 62 [!];"
;             , "time + pitch 58 [sfz];" ]
; 
; 
; events =  "\n"
;        ++ "part tpt\n"
;        ++ tptPart
;        ++ "\n"
;        ++ "part db clef bass\n"
;        ++ "time + pitch 38[>];"
; 
; events2 = join "\n" (take 15 (loop events))
; 
; output = header ++ "\n\n" ++ instruments ++ "\n\n" ++ events2  




main _ = do
    text = fomus ([], parts, info)
    print text
    export text









; ============================================================
; FOMUS

; Interface to the FOMUS notation engine by David Psenicka
; See http://fomus.sourceforge.net/

; The workflow is to create a data structure representing a score
; and pass it to the fomus function. This function generates a
; text on a format understood by FOMUS, which may be written to
; a fms file.

; Basic values
time    = prec
dur     = prec
grace   = prec
pitch   = prec
dynamic = float
voice   = int
ident   = str

; Mapping from string to value (this is used a lot)
setting  = (str, (str | num | [str] | [num]))


; Containers
template = str
perc     = (template, [setting])
clef     = [setting]
staff    = ([clef], [setting])
inst     = ident | (template, [perc], [staff], [setting])
part     = (ident, inst, [setting])
; metapart = ([part, metapart], [setting]) TODO

; Marks can be represented by a single string (same as in FOMUS files)
; or as a tuple, containing arguments. We define some common cases as
; symbols as well.

markId  = "(.." | "*" | "+" | "-" | "."
        | ".((." | ".(." | "..)" | "..))"
        | "..<" | "..>" | "."
        | "dash)" | "..dash))"
        | "..dot)" | "..dot))"
        | "..grace)"
        | "..ped"
        | "..tup"
        | "..x!" | "..x^" | "..x_" | ".<." | ".>."
        | ".dash((." | ".dash(."
        | ".dot((." | ".dot(."
        | ".grace(."
        | ".ped."
        | ".x!." | ".x^." | ".x_."
        | "/" | "/."
        | "0"
        | "<.." | ">" | ">.."
        | "^"
        | "arco" | "arp" | "arp^" | "arp_"
        | "artharm-base" | "artharm-sounding" | "artharm-touched"
        | "bellsup"
        | "break<" | "break>"
        | "breath" | "breath<" | "breath>"
        | "cuivre"
        | "damp"
        | "dash((.." | "dash(.."
        | "dot((.." | "dot(.."
        | "downbow"
        | "dyn"
        | "etouf"
        | "f"
        | "ferm" | "ferm-long" | "ferm-short" | "ferm-verylong"
        | "ff" | "fff" | "ffff" | "fffz" | "ffz"
        | "flaut"
        | "flt"
        | "fz"
        | "gliss<" | "gliss>"
        | "grace(.."
        | "leg"
        | "legno"
        | "longtr" | "longtr2"
        | "lv"
        | "mf"
        | "moltoleg" | "moltovib"
        | "mp"
        | "mute"
        | "natharm-sounding" | "natharm-string" | "natharm-touched"
        | "nonleg"
        | "nonvib"
        | "o"
        | "ord"
        | "p"
        | "ped.."
        | "pizz"
        | "pont"
        | "port<" | "port>"
        | "pp" | "ppp" | "pppp" | "ppppp" | "pppppp"
        | "punta"
        | "rf" | "rfz"
        | "ric"
        | "salt"
        | "sf" | "sff" | "sfff" | "sfffz" | "sffz" | "sfz"
        | "slap"
        | "snap" | "snappizz"
        | "spic"
        | "sul" | "table" | "tall" | "tasto"
        | "tempo"
        | "trem" | "trem2"
        | "tup.."
        | "unmute" | "upbow"
        | "vib"
        | "x" | "x!" | "x!.." | "x^" | "x^.." | "x_" | "x_.." | "~"
        | (`-) | (`.) | (`!) | (`+)
        | `f | `ff | `fff | `ffff
        | `mp | `mf
        | `p | `pp | `ppp | `pppp 

fff     = `fff
ff      = `ff
f       = `f
mf      = `mf
mp      = `mp
p       = `p
pp      = `pp
ppp     = `ppp

mark    = markId
        | ( markId, num )
        | ( markId, str )
        | ( markId, num, str )
        
; TODO sticky values:
;       time, duration, pitch, part, voice, dynamic, grace

note    = ( time, dur, grace, voice, part, pitch, dynamic, [mark], [setting] )
        | ( time, dur, grace, voice, part, pitch, dynamic, [mark] )
        | ( time, dur, grace, voice, part, pitch, dynamic )
        | ( time, dur, grace, voice, part, pitch, [mark] )
        | ( time, dur, grace, voice, part, pitch )

; FOMUS creates rests implicitly, the following form is only
; useful if you want to define marks or settings apart from
; a particular note event.

rest    = ( time, dur, grace, voice, part, [mark], [setting] )
        | ( time, dur, grace, voice, part, [mark] )
        | ( time, dur, grace, voice, part, [setting] )
        | ( time, dur, grace, voice, part )

; The same goes for measures. Measdefs are just to create
; explicit downbeats/time signature changes and so on.

measdef = ( time, dur, [setting] )
event   = note 
        | rest 
        | measdef
score   =  ([event], [part], [setting])
        |  ([], [part], [setting])


; Returns a string representation of the given FOMUS data,
; in the FOMUS native file format.

; score -> str
fomus data = match data
    (name, value) : setting = fomus name ++ " " ++ fomus (unescape value)
    (ident, inst, settings) : part = "part <" 
        ++ "id "   ++ ident 
        ++ " " ++ "inst " ++ fomus inst 
        ++ " " ++ fomus settings 
        ++ ">"
    (events, parts, settings) : score = join "\n\n"
        [fomus settings, fomus parts, fomus events]
    settings : [setting]    = join " " (map fomus settings)
    parts    : [part]       = join "\n" (map fomus parts)
    x : num                 = x
    x : str                 = x
    x : ()                  = ""



; Util
unescape x = match x
    x : str = "\"" ++ x ++ "\""
    x : num = x

; Output

fmsFile = FILE_LOCATION ++ FILE_NAME ++ ".fms"
xmlFile = FILE_LOCATION ++ FILE_NAME ++ ".xml"

; Writes the given text to a file and displays it
; () -> ()
export text = do
    writeFile fmsFile text
    run [ "fomus", fmsFile, "-o", xmlFile ]

    ; Workaround issue with FOMUS and clefs
    print "adjusting fomus clefs..."
    replaceFile xmlFile
        [ "<sign>F</sign>", "<sign>C</sign>" ]
        [ "<sign>F</sign><line>4</line>", "<sign>C</sign><line>3</line>" ]

    run [ "open", "-a", SCORE_EDITOR, xmlFile ]
