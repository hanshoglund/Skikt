; load "~/Documents/Musik/Skikt/Skikt.vitry"

; =============================================================================
; Skikt
; Hans Hoglund (2011)
; Vitry v0.1.x
; =============================================================================

module Hans.Music.Skikt

SCORE_EDITOR  = "/Applications/Sibelius 6.app"
FILE_LOCATION = "/Users/hans/Documents/Musik/Skikt/output/"
FILE_NAME     = "out"

; =============================================================================



info  = [ ("title", "Skikt")
        , ("author", "HH 2011") ]
    
insts = [ ("perc1", "percussion", ["snare-drum", "bass-drum"]) ]
winds = [ ("fl",   "flute",             [ ("abbr", "Fl") ])
        , ("ob",   "oboe",              [ ("abbr", "Ob") ])
        , ("cl",   "bflat-clarinet",    [ ("abbr", "Kl") ])
        , ("bsn",  "bassoon",           [ ("abbr", "Fag") ]) ]
brass = [ ("hrn",  "horn",              [ ("abbr", "Hrn") ])
        , ("tpt",  "bflat-trumpet",     [ ("abbr", "Tpt") ])
        , ("tbn",  "tenor-trombone",    [ ("abbr", "Tbn") ]) ]
            
percs = [ ("pno",  "piano",             [ ("abbr", "Pno") ])
        , ("vib",  "vibraphone",        [ ("abbr", "Vib") ])
        , ("crot", "vibraphone",        [ ("abbr", "Crot")
                                        , ("name", "Crotales") ])        
        , ("perc", "perc1",             [ ("abbr", "Perc") ]) ]
strs    = [ ("vl1",  "violin",            [ ("abbr", "Vl I") ])
        , ("vl2",  "violin",            [ ("abbr", "Vl II") ])
        , ("vla",  "viola",             [ ("abbr", "Vla") ])
        , ("vc",   "cello",             [ ("abbr", "Vc")
                                        , ("name", "Violoncello") ])   
        , ("db",   "bass",              [ ("abbr", "Kb") ]) ]

parts = winds ++ brass ++ percs ++ strs
decls = insts ++ parts

; header = "title Skikt"
;
; instruments = join "\n"
;             [ "part <id fl,   abbr Fl,        inst flute>"
;             , "part <id ob,   abbr Ob,        inst oboe>"
;             , "part <id cl,   abbr Kl,        inst bflat-clarinet>"
;             , "part <id bsn,  abbr Fag,       inst bassoon>"
; 
;             , "part <id hrn,  abbr Hrn,       inst horn>"
;             , "part <id tpt,  abbr Tpt,       inst bflat-trumpet>"
;             , "part <id tbn,  abbr Tbn,       inst tenor-trombone>"
; 
;             , "part <id pno,  abbr Pno,       inst piano>"
; 
;             , "part <id vb,   abbr Vib,       inst vibraphone>"
;             , "part <id crot, abbr Crot,      inst vibraphone, name Crotales>"
;             , "inst <id perc1, template percussion, percinsts (snare-drum bass-drum)>"
;             , "part <id perc, abbr Perc       inst perc1>"
; 
;             , "part <id vl1,  abbr \"Vl I\",  inst violin>"
;             , "part <id vl2,  abbr \"Vl II\", inst violin>"
;             , "part <id vla,  abbr Vla,       inst viola>"
;             , "part <id vc,   abbr Vc,        inst cello, name Violoncello>"
;             , "part <id db,   abbr Kb,        inst bass>" ]
; 
; 
; 
; tptPart =   join "\n" [ "time + dur 8/5 pitch 60;"
;             , "time + pitch 67 [>] [.];"
;             , "time + pitch 62 [!];"
;             , "time + pitch 58 [sfz];" ]
; 
; 
; events =  "\n"
;        ++ "part tpt\n"
;        ++ tptPart
;        ++ "\n"
;        ++ "part db clef bass\n"
;        ++ "time + pitch 38[>];"
; 
; events2 = join "\n" (take 15 (loop events))
; 
; output = header ++ "\n\n" ++ instruments ++ "\n\n" ++ events2  




main _ = do
    text = fomus ([], decls, info)
    print text
    export text

test _ = fomus ([], decls, info)








; =============================================================================
; FOMUS

; Interface to the FOMUS notation engine by David Psenicka
; See http://fomus.sourceforge.net/

; The workflow is to create a data structure representing a score
; and pass it to the fomus function. This function generates a
; text on a format understood by FOMUS, which may be written to
; a fms file.

; Basic values
time    = prec
dur     = prec
grace   = prec
pitch   = prec
dynamic = float
voice   = int
ident   = str

; Mapping from string to value (this is used a lot)
setting  = (str, (str | num | [str] | [num]))


; Containers
templ    = ident
perc     = templ 
         | (ident, [setting])
clef     = [setting]
staff    = ([clef], [setting])
inst     = templ
         | (ident, templ, [perc])
         | (ident, templ, [perc], [staff])
         | (ident, templ, [perc], [staff], [setting])
part     = (ident, inst, [setting])
; metapart = ([part, metapart], [setting]) TODO

; Marks can be represented by a single string (same as in FOMUS files)
; or as a tuple, containing arguments. We define some common cases as
; symbols as well.
markId  = "(.." | "*" | "+" | "-" | "."
        | ".((." | ".(." | "..)" | "..))"
        | "..<" | "..>" | "."
        | "dash)" | "..dash))"
        | "..dot)" | "..dot))"
        | "..grace)"
        | "..ped"
        | "..tup"
        | "..x!" | "..x^" | "..x_" | ".<." | ".>."
        | ".dash((." | ".dash(."
        | ".dot((." | ".dot(."
        | ".grace(."
        | ".ped."
        | ".x!." | ".x^." | ".x_."
        | "/" | "/."
        | "0"
        | "<.." | ">" | ">.."
        | "^"
        | "arco" | "arp" | "arp^" | "arp_"
        | "artharm-base" | "artharm-sounding" | "artharm-touched"
        | "bellsup"
        | "break<" | "break>"
        | "breath" | "breath<" | "breath>"
        | "cuivre"
        | "damp"
        | "dash((.." | "dash(.."
        | "dot((.." | "dot(.."
        | "downbow"
        | "dyn"
        | "etouf"
        | "f"
        | "ferm" | "ferm-long" | "ferm-short" | "ferm-verylong"
        | "ff" | "fff" | "ffff" | "fffz" | "ffz"
        | "flaut"
        | "flt"
        | "fz"
        | "gliss<" | "gliss>"
        | "grace(.."
        | "leg"
        | "legno"
        | "longtr" | "longtr2"
        | "lv"
        | "mf"
        | "moltoleg" | "moltovib"
        | "mp"
        | "mute"
        | "natharm-sounding" | "natharm-string" | "natharm-touched"
        | "nonleg"
        | "nonvib"
        | "o"
        | "ord"
        | "p"
        | "ped.."
        | "pizz"
        | "pont"
        | "port<" | "port>"
        | "pp" | "ppp" | "pppp" | "ppppp" | "pppppp"
        | "punta"
        | "rf" | "rfz"
        | "ric"
        | "salt"
        | "sf" | "sff" | "sfff" | "sfffz" | "sffz" | "sfz"
        | "slap"
        | "snap" | "snappizz"
        | "spic"
        | "sul" | "table" | "tall" | "tasto"
        | "tempo"
        | "trem" | "trem2"
        | "tup.."
        | "unmute" | "upbow"
        | "vib"
        | "x" | "x!" | "x!.." | "x^" | "x^.." | "x_" | "x_.." | "~"
        | (`-) | (`.) | (`!) | (`+)
        | `f | `ff | `fff | `ffff
        | `mp | `mf
        | `p | `pp | `ppp | `pppp 

fff     = `fff
ff      = `ff
f       = `f
mf      = `mf
mp      = `mp
p       = `p
pp      = `pp
ppp     = `ppp

mark    = markId
        | ( markId, num )
        | ( markId, str )
        | ( markId, num, str )
        
; TODO sticky values: time, duration, pitch, part, voice, dynamic, grace
note    = ( time, dur, grace, voice, part, pitch, dynamic, [mark], [setting] )
        | ( time, dur, grace, voice, part, pitch, dynamic, [mark] )
        | ( time, dur, grace, voice, part, pitch, dynamic )
        | ( time, dur, grace, voice, part, pitch, [mark] )
        | ( time, dur, grace, voice, part, pitch )

; FOMUS creates rests implicitly, the following form is only
; useful if you want to define marks or settings apart from
; a particular note event.
rest    = ( time, dur, grace, voice, part, [mark], [setting] )
        | ( time, dur, grace, voice, part, [mark] )
        | ( time, dur, grace, voice, part, [setting] )
        | ( time, dur, grace, voice, part )

; The same goes for measures. Measdefs are just to create
; explicit downbeats/time signature changes and so on.
measdef = ( time, dur, [setting] )

event   = note | rest | measdef
decl    = part | inst | perc | clef | staff
score   =  ([event], [decl], [setting])
        |  ([], [decl], [setting])

; =============================================================================

; Returns a string representation of the given FOMUS data.

fomus data = match data
                      
    ; TODO perc
    ; TODO clef
    ; TODO staff
    (id, templ, percs)        : inst = "inst <"
                                           ++ "id " ++ id
                                    ++ " " ++ "template " ++ fomus templ 
                                    ++ " " ++ "percinsts " ++ fomusList percs
                                    ++ ">"
    ; TODO mark
    ; TODO note
    ; TODO rest
    ; TODO measdef
    (name, value)             : setting = fomus name ++ " " ++ fomus (unescape value)
    (id, inst, settings)      : part    = "part <"
                                           ++ "id "   ++ id 
                                    ++ " " ++ "inst " ++ fomus inst 
                                    ++ " " ++ fomus settings 
                                    ++ ">"    
    (events, decls, settings) : score  = join "\n\n" [fomus settings, fomus decls, fomus events]
    
    event    : [event]      = join "\n" (map fomus event)
    decls    : [decl]       = join "\n" (map fomus decls)
    settings : [setting]    = join " " (map fomus settings)
    x : num                 = x
    x : str                 = x
    x : ()                  = ""

fomusList xs = "(" ++ join " " (map fomus xs) ++ ")"


; =============================================================================
; Util

unescape x = match x
    x : str = "\"" ++ x ++ "\""
    x : num = x



; =============================================================================
; Output

fmsFile = FILE_LOCATION ++ FILE_NAME ++ ".fms"
xmlFile = FILE_LOCATION ++ FILE_NAME ++ ".xml"


; Writes the given text to a file and displays it

export text = do
    
    writeFile fmsFile text
    run [ "fomus", fmsFile, "-o", xmlFile ]

    ; Work around issue with FOMUS and clefs
    print "adjusting fomus clefs..."
    replaceFile xmlFile
        [ "<sign>F</sign>", "<sign>C</sign>" ]
        [ "<sign>F</sign><line>4</line>", "<sign>C</sign><line>3</line>" ]

    run [ "open", "-a", SCORE_EDITOR, xmlFile ]
