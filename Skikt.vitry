; load "~/Documents/Musik/Skikt/Skikt.vitry"

; =============================================================================
; Skikt
; Hans Hoglund (2011)
; Vitry v0.1.2
; =============================================================================

module Hans.Music.Skikt

; Setup

scoreEditor = "/Applications/Sibelius 6.app"
fileDir     = "/Users/hans/Documents/Musik/Skikt/output/"
fileName    = "out"
preview     = false
fixClefs    = false

info  = [ ("title",  "Skikt")
        , ("author", "Hans Hoglund 2011") ]


; Parts

insts = [ ("perc1", "percussion", ["snare-drum", "bass-drum", "crash-cymbal", "splash-cymbal"]) ]

winds = [ ("fl",   "flute",             [ ("abbr", "Fl.") ])
        , ("ob",   "oboe",              [ ("abbr", "Ob.") ])
        , ("cl",   "bflat-clarinet",    [ ("abbr", "Kl.") ])
        , ("bsn",  "bassoon",           [ ("abbr", "Fag.") ]) ]
brass = [ ("hrn",  "horn",              [ ("abbr", "Hrn.") ])
        , ("tpt",  "bflat-trumpet",     [ ("abbr", "Tpt.") ])
        , ("tbn",  "tenor-trombone",    [ ("abbr", "Tbn.") ]) ]
percs = [ ("pno",  "piano",             [ ("abbr", "Pno.") ])
        , ("vib",  "vibraphone",        [ ("abbr", "Vib.") ])
        , ("crot", "vibraphone",        [ ("abbr", "Crot.")
                                        , ("name", "Crotales") ])
        , ("perc", "perc1",             [ ("abbr", "Perc.")
                                        , ("name", "Percussion")]) ]
strs  = [ ("vl1",  "violin",          [ ("abbr", "Vl. I") ])
        , ("vl2",  "violin",            [ ("abbr", "Vl. II") ])
        , ("vla",  "viola",             [ ("abbr", "Vla.") ])
        , ("vc",   "cello",             [ ("abbr", "Vc.")
                                        , ("name", "Violoncello") ])
        , ("db",   "bass",              [ ("abbr", "Kb.") ]) ]

fl = index 0 winds
cl = index 2 winds

parts = winds ++ brass ++ percs ++ strs
decls = insts ++ parts

snareDrum = `snareDrum
bassDrum  = `bassDrum
smallCymbal = `smallCymbal 
largeCymbal = `largeCymbal

percNote inst = match inst
    x : bassDrum    = 65
    x : snareDrum   = 72
    x : smallCymbal = 76
    x : largeCymbal = 79


; Events






durs = (loop 1)
pitches = (loop (percNote largeCymbal))
dyns = (loop 1.0)



events = take 20 
    zip5 durs pitches dyns (loop []) (loop [])





; Main program

main _ = (export . fomus) (events, decls, info)
test _ = fomus (events, decls, info)




; =============================================================================
; FOMUS

; Interface to the FOMUS notation engine by David Psenicka
; See http://fomus.sourceforge.net/

; The workflow is to create a data structure representing a score
; and pass it to the fomus function. This function generates a
; text on a format understood by FOMUS, which may be written to
; a fms file.

; Fomus allows many fields to be "unset", assuming the previous value
; We represent this by nil

time       = prec   | nil | "+"
grace      = prec   | nil | "+"
dur        = prec   | nil | "+" | "-"
pitch      = prec   | nil
dyn        = double | nil
voice      = int    | nil | [int]

identifier = str
setting    = (str, (str | num | [str] | [num]))

markSign   = "(.." | "*" | "+" | "-" | "." | ".((." | ".(." | "..)" | "..))" | "..<"
           | "..>" | "." | "dash)" | "..dash))" | "..dot)" | "..dot))" | "..grace)"
           | "..ped" | "..tup" | "..x!" | "..x^" | "..x_" | ".<." | ".>." | ".dash((."
           | ".dash(." | ".dot((." | ".dot(." | ".grace(." | ".ped." | ".x!." | ".x^."
           | ".x_." | "/" | "/." | "0" | "<.." | ">" | ">.." | "^" | "arco" | "arp"
           | "arp^" | "arp_" | "artharm-base" | "artharm-sounding" | "artharm-touched"
           | "bellsup" | "break<" | "break>" | "breath" | "breath<" | "breath>"
           | "cuivre" | "damp" | "dash((.." | "dash(.." | "dot((.." | "dot(.."
           | "downbow" | "dyn" | "etouf" | "f" | "ferm" | "ferm-long" | "ferm-short"
           | "ferm-verylong" | "ff" | "fff" | "ffff" | "fffz" | "ffz" | "flaut" | "flt"
           | "fz" | "gliss<" | "gliss>" | "grace(.." | "leg" | "legno" | "longtr"
           | "longtr2" | "lv" | "mf" | "moltoleg" | "moltovib" | "mp" | "mute"
           | "natharm-sounding" | "natharm-string" | "natharm-touched" | "nonleg"
           | "nonvib" | "o" | "ord" | "p" | "ped.." | "pizz" | "pont" | "port<"
           | "port>" | "pp" | "ppp" | "pppp" | "ppppp" | "pppppp" | "punta" | "rf"
           | "rfz" | "ric" | "salt" | "sf" | "sff" | "sfff" | "sfffz" | "sffz" | "sfz"
           | "slap" | "snap" | "snappizz" | "spic" | "sul" | "table" | "tall" | "tasto"
           | "tempo" | "trem" | "trem2" | "tup.." | "unmute" | "upbow" | "vib" | "x"
           | "x!" | "x!.." | "x^" | "x^.." | "x_" | "x_.." | "~" | (`-) | (`.) | (`!) | (`+)

template   = identifier

clef    = [setting]
staff   = ( [clef], [setting] )

perc    = template
        | ( identifier, [setting] )
inst    = template
        | ( identifier, template, [perc] )
        | ( identifier, template, [perc], [staff] )
        | ( identifier, template, [perc], [staff], [setting] )

part    = nil | (identifier, inst, [setting])

mark    = markSign
        | ( markSign, (num | str) )
        | ( markSign, (num | str), (num | str) )

; We define some sparse forms of the events for convenience

note    = ( part,   voice,   time,    grace,   dur,     pitch,   dyn,     [mark],  [setting] )
        | ( part,   voice,   time,    dur,     pitch,   dyn,     [mark],  [setting]          )
        | ( time,   dur,     pitch,   dyn,     [mark],  [setting]                            )
        | ( dur,    pitch,   dyn,     [mark],  [setting]                                     )
        | ( pitch,  dyn,     [mark],  [setting]                                              )
rest    = ( part,   voice,   time,    grace,   dur,     [mark],  [setting]                   )
        | ( time,   dur,     [mark],  [setting]                                              )
measure = ( time,   dur,     [setting]                                                       )
        | ( dur,    [setting]                                                                )

decl    = part | inst | perc | staff | clef
event   = note | rest | measure

score   = ( [event], [decl], [setting] )



; Utils

; Expands a sparse event to its complete form, substituting nil for all missing slots 
;   event -> event
expandEvent e : event = match e
    ( r, v, t, d, p, n:dyn, ms, ss ) : note    = ( r,  v,  t,  (), d,  p, n, ms, ss )
    ( t, d, p, n:dyn, ms, ss )       : note    = ( (), (), t,  (), d,  p, n, ms, ss )
    ( d, p, n:dyn, ms, ss )          : note    = ( (), (), (), (), d,  p, n, ms, ss )
    ( p, n:dyn, ms, ss )             : note    = ( (), (), (), (), (), p, n, ms, ss )
    ( t, d, ms, ss )                 : rest    = ( (), (), t,  (), d,  ms, ss )
    ( d, ss )                        : measure = ( (), d, ss )

getNDur   ( _, _, _, _, d, _, _, _, _ ) = d
getNPitch ( _, _, _, _, _, p, _, _, _ ) = p
getNDyn   ( _, _, _, _, _, _, n, _, _ ) = n
getRDur   ( _, _, _, _, d, _, _ )       = d
getMDur   ( d, _ )                      = d
setNPart  r ( _, v, t, g, d, p, n, ms, ss ) = (r, v, t, g, d, p, n, ms, ss)
setNVoice v ( r, _, t, g, d, p, n, ms, ss ) = (r, v, t, g, d, p, n, ms, ss)
setNTime  t ( r, v, _, g, d, p, n, ms, ss ) = (r, v, t, g, d, p, n, ms, ss)
setNGrace g ( r, v, t, _, d, p, n, ms, ss ) = (r, v, t, g, d, p, n, ms, ss)
setNDur   d ( r, v, t, g, _, p, n, ms, ss ) = (r, v, t, g, d, p, n, ms, ss)
setNPitch p ( r, v, t, g, d, _, n, ms, ss ) = (r, v, t, g, d, p, n, ms, ss)
setNDyn   n ( r, v, t, g, d, p, _, ms, ss ) = (r, v, t, g, d, p, n, ms, ss)
setNMarks n ( r, v, t, g, d, p, n, _,  ss ) = (r, v, t, g, d, p, n, ms, ss)

;   event -> dur
getDur e = match (expandEvent e)
    e : note    = getNDur e
    e : rest    = getRDur e
    e : measure = getMDur e

;   note -> pitch
getPitch = getNPitch . expandEvent
getDyn   = getNDyn . expandEvent

;   part -> id
getId (id, _, _) : part = id


; Simple inspectors for the repl
    
declType d = match d
    d : part    = `part
    d : inst    = `inst
    d : perc    = `perc
    d : staff   = `staff
    d : clef    = `clef

eventType e = match e
    e : note    = `note
    e : rest    = `rest
    e : measure = `measure



; Export

; Returns a string representation of the given FOMUS data.
;    ( mark  |  decl  |  event  | setting | [mark] | [decl] | [event] | [setting] | score ) -> str
fomus data = match data

    (id, x, y)                : mark = "[" ++ string id ++ " " ++ fomus x ++ " " ++ fomus y ++ "]"
    (id, x)                   : mark = "[" ++ string id ++ " " ++ fomus x ++ "]"
    id                        : mark = "[" ++ string id ++ "]"
    
    (name, value)             : setting = name ++ "=" ++ fomus value

    (id, template, percs)     : inst = "inst <"
                                    ++ "id="        ++ id              ++ " " 
                                    ++ "template="  ++ fomus template  ++ " " 
                                    ++ "percinsts=" ++ fomusList percs ++ ">"
    (id, inst, settings)      : part = "part <"
                                    ++ "id="   ++ id         ++ " " 
                                    ++ "inst=" ++ fomus inst ++ " " 
                                    ++ fomus settings        ++ ">"
    
    (part, voice, time, grace, dur, pitch, dyn, marks, settings) : note = ""
                                    ++ maybePart part   ++ " " 
                                    ++ maybeVoice voice ++ " " 
                                    ++ maybeTime time   ++ " " 
                                    ++ maybeGrace grace ++ " " 
                                    ++ maybeDur dur     ++ " " 
                                    ++ maybePitch pitch ++ " " 
                                    ++ maybeDynamic dyn ++ " " 
                                    ++ fomus marks      ++ " " 
                                    ++ fomus settings   ++ ";"
    (part, voice, time, grace, dur, marks, settings) : rest = "rest "
                                    ++ maybePart part   ++ " " 
                                    ++ maybeVoice voice ++ " " 
                                    ++ maybeTime time   ++ " " 
                                    ++ maybeGrace grace ++ " " 
                                    ++ maybeDur dur     ++ " " 
                                    ++ fomus marks      ++ " " 
                                    ++ fomus settings   ++ ";"
    (time, dur, settings)     : measure = ""
                                    ++ maybeTime time   ++ " "
                                    ++ maybeDur  dur    ++ " "
                                    ++ "measure <" ++ fomus settings ++ ">"
    event                     : event = (fomus . expandEvent) event

    (events, decls, settings) : score = join "\n\n" [fomus settings, fomus decls, fomus events]

    settings : [setting]    = join " " (map fomus settings)
    marks    : [mark]       = join " " (map fomus marks)
    event    : [event]      = join "\n" (map fomus event)
    decls    : [decl]       = join "\n" (map fomus decls)
    x        : str          = fomusStr x
    x        : num          = string x
    x        : ()           = ""
    xs       : [_]          = fomusList xs

fomusList xs = "(" ++ join " " (map fomus xs) ++ ")"
fomusStr x   = "\"" ++ x ++ "\""

maybePart x    = match x (x : () = "") (x = "part="    ++ getId x)
maybeVoice x   = match x (x : () = "") (x = "voice="   ++ string x)
maybeTime x    = match x (x : () = "") (x = "time="    ++ string x)
maybeGrace x   = match x (x : () = "") (x = "grace="   ++ string x)
maybeDur x     = match x (x : () = "") (x = "dur="     ++ string x)
maybePitch x   = match x (x : () = "") (x = "pitch="   ++ string x)
maybeDynamic x = match x (x : () = "") (x = "dynamic=" ++ string x)



; =============================================================================
; Output

fmsFile = fileDir ++ fileName ++ ".fms"
xmlFile = fileDir ++ fileName ++ ".xml"
lyFile  = fileDir ++ fileName ++ ".ly"


; Writes the given text to a file and displays it

export text = do
    writeFile fmsFile text
    if preview
        do run [ "fomus", fmsFile, "-o", lyFile ]
        ; else
        do run [ "fomus", fmsFile, "-o", xmlFile ]
            if fixClefs 
                do print "adjusting fomus clefs..."
                    replaceFile xmlFile
                        [ "<sign>F</sign>", "<sign>C</sign>" ]
                        [ "<sign>F</sign><line>4</line>", "<sign>C</sign><line>3</line>" ]
                ; else
                ()
            ; Open the score
            run [ "open", "-a", scoreEditor, xmlFile ]
