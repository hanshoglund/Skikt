; load "~/Documents/Musik/Skikt/Skikt.vitry"

; =============================================================================
; Skikt
; Hans Hoglund (2011)
; Vitry v0.1.2
; =============================================================================

module Hans.Music.Skikt

scoreEditor = "/Applications/Sibelius 6.app"
fileDir     = "/Users/hans/Documents/Musik/Skikt/output/"
fileName    = "out"
preview     = false
fixClefs    = false

info  = [ ("title",  "Skikt")
        , ("author", "Hans Hoglund 2011") ]

insts = [ ("perc1", "percussion", ["snare-drum2", "bass-drum2"]) ]

winds = [ ("fl",   "flute",             [ ("abbr", "Fl.") ])
        , ("ob",   "oboe",              [ ("abbr", "Ob.") ])
        , ("cl",   "bflat-clarinet",    [ ("abbr", "Kl.") ])
        , ("bsn",  "bassoon",           [ ("abbr", "Fag.") ]) ]
brass = [ ("hrn",  "horn",              [ ("abbr", "Hrn.") ])
        , ("tpt",  "bflat-trumpet",     [ ("abbr", "Tpt.") ])
        , ("tbn",  "tenor-trombone",    [ ("abbr", "Tbn.") ]) ]
percs = [ ("pno",  "piano",             [ ("abbr", "Pno.") ])
        , ("vib",  "vibraphone",        [ ("abbr", "Vib.") ])
        , ("crot", "vibraphone",        [ ("abbr", "Crot.")
                                        , ("name", "Crotales") ])
        , ("perc", "perc1",             [ ("abbr", "Perc.")
                                        , ("name", "Percussion")]) ]
strs    = [ ("vl1",  "violin",          [ ("abbr", "Vl. I") ])
        , ("vl2",  "violin",            [ ("abbr", "Vl. II") ])
        , ("vla",  "viola",             [ ("abbr", "Vla.") ])
        , ("vc",   "cello",             [ ("abbr", "Vc.")
                                        , ("name", "Violoncello") ])
        , ("db",   "bass",              [ ("abbr", "Kb.") ]) ]



snareDrum = `snareDrum
bassDrum  = `bassDrum
percNote inst = match inst
    x : snareDrum = 72
    x : bassDrum  = 65

parts = winds ++ brass ++ percs ++ strs
; parts = winds
decls = insts ++ parts




randoms x = unroll (pluck random x)

melody part = zip3With (fn (time dur pitch) (part, 1, time, (), dur, pitch, (randomDouble ()), [("x_", "dolce")], []))
nothing part = map (fn (dur) (part, 1, "+", [], dur, [], []))

myPart = index 3 percs
notes = melody myPart (loop "+") (map (+ 1) (randoms 4)) (unroll (pluck pick [percNote snareDrum, percNote bassDrum]))
rests = nothing myPart (loop ((11/3) * 5))


events = take 40 (interl notes rests)
; events = take 30 notes































main _ = (export . fomus) (events, decls, info)
test _ = fomus (events, decls, info)






; =============================================================================
; FOMUS

; Interface to the FOMUS notation engine by David Psenicka
; See http://fomus.sourceforge.net/

; The workflow is to create a data structure representing a score
; and pass it to the fomus function. This function generates a
; text on a format understood by FOMUS, which may be written to
; a fms file.

; Data

pitch      = prec
dynamic    = double
time       = prec | "+" | ()
grace      = prec | "+" | ()
dur        = prec | "+" | "-" | ()
voice      = int
identifier = str
setting    = (str, (str | num | [str] | [num]))
markSign   = "(.." | "*" | "+" | "-" | "." | ".((." | ".(." | "..)" | "..))" | "..<"
           | "..>" | "." | "dash)" | "..dash))" | "..dot)" | "..dot))" | "..grace)"
           | "..ped" | "..tup" | "..x!" | "..x^" | "..x_" | ".<." | ".>." | ".dash((."
           | ".dash(." | ".dot((." | ".dot(." | ".grace(." | ".ped." | ".x!." | ".x^."
           | ".x_." | "/" | "/." | "0" | "<.." | ">" | ">.." | "^" | "arco" | "arp"
           | "arp^" | "arp_" | "artharm-base" | "artharm-sounding" | "artharm-touched"
           | "bellsup" | "break<" | "break>" | "breath" | "breath<" | "breath>"
           | "cuivre" | "damp" | "dash((.." | "dash(.." | "dot((.." | "dot(.."
           | "downbow" | "dyn" | "etouf" | "f" | "ferm" | "ferm-long" | "ferm-short"
           | "ferm-verylong" | "ff" | "fff" | "ffff" | "fffz" | "ffz" | "flaut" | "flt"
           | "fz" | "gliss<" | "gliss>" | "grace(.." | "leg" | "legno" | "longtr"
           | "longtr2" | "lv" | "mf" | "moltoleg" | "moltovib" | "mp" | "mute"
           | "natharm-sounding" | "natharm-string" | "natharm-touched" | "nonleg"
           | "nonvib" | "o" | "ord" | "p" | "ped.." | "pizz" | "pont" | "port<"
           | "port>" | "pp" | "ppp" | "pppp" | "ppppp" | "pppppp" | "punta" | "rf"
           | "rfz" | "ric" | "salt" | "sf" | "sff" | "sfff" | "sfffz" | "sffz" | "sfz"
           | "slap" | "snap" | "snappizz" | "spic" | "sul" | "table" | "tall" | "tasto"
           | "tempo" | "trem" | "trem2" | "tup.." | "unmute" | "upbow" | "vib" | "x"
           | "x!" | "x!.." | "x^" | "x^.." | "x_" | "x_.." | "~" | (`-) | (`.) | (`!) | (`+)
templ   = identifier

clef    = [setting]
staff   = ([clef], [setting])

perc    = templ
        | (identifier, [setting])
inst    = templ
        | (identifier, templ, [perc])
        | (identifier, templ, [perc], [staff])
        | (identifier, templ, [perc], [staff], [setting])

part    = (identifier, inst, [setting])

mark    = markSign
        | (markSign, num)
        | (markSign, str)
        | (markSign, num, str)

note    = (part, voice, time, grace, dur, pitch, dynamic, [mark], [setting])
        | (time, dur, pitch, dynamic, [mark], [setting])
        | (dur, pitch, dynamic, [mark], [setting])
        | (pitch, dynamic, [mark], [setting])
        | (time, dur, pitch, [mark], [setting])
        | (dur, pitch, [mark], [setting])
        | (pitch, [mark], [setting])
rest    = (part, voice, time, grace, dur, [mark], [setting])
measdef = (time, dur, [setting])
        | (dur, [setting])

decl    = part | inst | perc | staff | clef
event   = note | rest | measdef

score   = ([event], [decl], [setting])


; Utils

; part -> id
getId (id, _, _) : part = id

; note -> pitch
getPitch n = match n
    (_, _, _, _, _, p, _, _, _) : (_, _, _, _, _, pitch, _, _, _) = p
    ; (_, _, p, _, _, _)          : (_, _, pitch, _, _, _) = p
    ; (_, p, _, _, _)             : (_, pitch, _, _, _) = p
    ; (p, _, _, _)                : (pitch, _, _, _) = p
    ; (_, _, p, _, _)             : (_, _, pitch, _, _) = p
    ; (_, p, _, _)                : (_, pitch, _, _) = p
    ; (p, _, _)                   : (pitch, _, _) = p
    _ : note = ()

; event -> dur
getDur n = match n
    (_, _, _, _, d, _, _, _, _) : (_, _, _, _, dur, _, _, _, _) = d
    (_, _, _, _, d, _, _)       : (_, _, _, _, dur, _, _) = d
    ; (_, d, _, _, _, _)          : (_, dur, _, _, _, _) = d
    ; (d, _, _, _, _)             : (dur, _, _, _, _) = d
    ; (_, d, _, _, _)             : (_, dur, _, _, _) = d
    ; (d, _, _, _)                : (dur, _, _, _) = d
    ; (_, d, _)                   : (_, dur, _) = d
    ; (d, _)                      : (dur, _) = d
    _ : event = ()



; Export

; Returns a string representation of the given FOMUS data.
; TODO clef staff perc metapart

; setting | inst | part | mark | note | rest | measdef | score -> str
fomus data = match data

    (id, x, y)                : mark = "[" ++ string id ++ " " ++ fomus x ++ " " ++ fomus y ++ "]"
    (id, x)                   : mark = "[" ++ string id ++ " " ++ fomus x ++ "]"
    id                        : mark = "[" ++ string id ++ "]"
    
    (name, value)             : setting = name ++ " " ++ fomus value

    (id, templ, percs)        : inst = "inst <"
                                           ++ "id=" ++ id              ++ " " 
                                    ++ "template="  ++ fomus templ     ++ " " 
                                    ++ "percinsts=" ++ fomusList percs ++ ">"
    (id, inst, settings)      : part = "part <"
                                    ++ "id="   ++ id         ++ " " 
                                    ++ "inst=" ++ fomus inst ++ " " 
                                    ++ fomus settings        ++ ">"
    
    (part, voice, time, grace, dur, pitch, dyn, marks, settings) : note = ""
                                    ++ maybePart part   ++ " " 
                                    ++ maybeVoice voice ++ " " 
                                    ++ maybeTime time   ++ " " 
                                    ++ maybeGrace grace ++ " " 
                                    ++ maybeDur dur     ++ " " 
                                    ++ maybePitch pitch ++ " " 
                                    ++ maybeDynamic dyn ++ " " 
                                    ++ fomus marks      ++ " " 
                                    ++ fomus settings   ++ ";"
    ; (time, dur, pitch, dyn, marks, settings) : note = fomus ((), (), time, (), dur, pitch, dyn, marks, settings)
    ; (dur, pitch, dyn, marks, settings) : note       = fomus ((), (), (), (), dur, pitch, dyn, marks, settings)
    ; (time, dur, pitch, marks, settings) : note      = fomus ((), (), time, (), dur, pitch, marks, settings)
    ; (dur, pitch, marks, settings) : note            = 
    ; (pitch, marks, settings)  : note                = 
    (part, voice, time, grace, dur, marks, settings) : rest = "rest "
                                    ++ maybePart part   ++ " " 
                                    ++ maybeVoice voice ++ " " 
                                    ++ maybeTime time   ++ " " 
                                    ++ maybeGrace grace ++ " " 
                                    ++ maybeDur dur     ++ " " 
                                    ++ fomus marks      ++ " " 
                                    ++ fomus settings   ++ ";"
    (time, dur, settings)     : measdef = ""
                                           ++ maybeTime time
                                    ++ " " ++ maybeDur  dur
                                    ++ " " ++ "measure=<" ++ fomus settings ++ ">"

    (events, decls, settings) : score  = join "\n\n" [fomus settings, fomus decls, fomus events]

    event    : [event]      = join "\n" (map fomus event)
    decls    : [decl]       = join "\n" (map fomus decls)
    marks    : [mark]       = join " " (map fomus marks)
    settings : [setting]    = join " " (map fomus settings)
    x        : str          = fomusStr x
    x        : num          = string x
    x        : ()           = ""
    xs       : [_]          = fomusList xs

fomusList xs = "(" ++ join " " (map fomus xs) ++ ")"
fomusStr x   = "\"" ++ x ++ "\""

maybePart x    = match x (x : () = "") (x = "part="    ++ getId x)
maybeVoice x   = match x (x : () = "") (x = "voice="   ++ string x)
maybeTime x    = match x (x : () = "") (x = "time="    ++ string x)
maybeGrace x   = match x (x : () = "") (x = "grace="   ++ string x)
maybeDur x     = match x (x : () = "") (x = "dur="     ++ string x)
maybePitch x   = match x (x : () = "") (x = "pitch="   ++ string x)
maybeDynamic x = match x (x : () = "") (x = "dynamic=" ++ string x)


; =============================================================================
; Output

fmsFile = fileDir ++ fileName ++ ".fms"
xmlFile = fileDir ++ fileName ++ ".xml"
lyFile  = fileDir ++ fileName ++ ".ly"


; Writes the given text to a file and displays it

export text = do
    writeFile fmsFile text
    if preview
        do run [ "fomus", fmsFile, "-o", lyFile ]
        ; else
        do run [ "fomus", fmsFile, "-o", xmlFile ]
            if fixClefs 
                do print "adjusting fomus clefs..."
                    replaceFile xmlFile
                        [ "<sign>F</sign>", "<sign>C</sign>" ]
                        [ "<sign>F</sign><line>4</line>", "<sign>C</sign><line>3</line>" ]
                ; else
                ()
            ; Open the score
            run [ "open", "-a", scoreEditor, xmlFile ]
